window.searchIndex = [{"url":"https://yzzfo.github.io/blog/","title":"List of blog posts","description":null,"body":"","path":null},{"url":"https://yzzfo.github.io/blog/将iPad作为Windos副屏的方案/","title":"将iPad作为Windos副屏的方案","description":null,"body":"  几年前尝试过将iPad作为副屏，但app store上的方案基本上都存在延迟过高，画面模糊的问题，今天研究了以下后发现了一些新的方案。\n串流+虚拟屏幕\n该方案在局域网的情况下延迟和画质都十分优秀，核心逻辑就是串流虚拟屏幕达到副屏的效果\n串流软件\n\nsunshine + moonlight\nrustdesk\ngameview\n\n虚拟屏幕\n\nParsecVDisplay  ( https://github.com/nomi-san/parsec-vdd )\n\n其他问题\nsunshine\n\n功耗过高，默认情况下sunshine使用了n卡的倾向于较低的编码延迟而不是省电导致空载功耗过高，需要将其禁用即可降低功耗，在sunshine的NVIDIA NVENC Encoder中可以找到该选项（ https://github.com/LizardByte/Sunshine/issues/1908 ）\n音频，如果不想将音频传输到iPad，可以将捕获的音频设备设置为一个不存在的设备。\n\nSunshine-Foundation\n该版本内置了虚拟屏幕驱动，且配置了hdr等一些高阶功能，可用于iPad进行hdr显示\nmoonlight-ios-NativeMultiTouchPassthrough\n该版本的moonlight可以处理iPad多点操作，apple pencil等，这样就可以作为一个可触摸的windows副屏\ngameview\n\n副屏无法显示鼠标指针，在控制端点击【操作】-【启用按键映射】-【切换操控方案】选择【办公常用】方案，并选择【屏幕触控】模式，开启完成后，鼠标就会在控制端显示出来；( https://feedback-web.webapp.163.com/qa_detail/331 )\n\n现成的副屏软件\n这些软件处于基本能用的状态，要求不高的情况下可以使用\n\nspacedesk整体速度和画面还算不错。\nduet和spacedesk差不多\n\n副屏Windos下的配置\n\n任务栏，可以通过个性化-任务栏-当使用多个显示器时，在以下位置显示我都任务栏应用设置为打开了窗口的任务栏，这样任务栏只会显示在当前屏幕中的任务。\n\n总结\n总体测试下来，Sunshine-Foundation+moonlight-ios-NativeMultiTouchPassthrough的效果是最理想的，组件的屏幕兼容触摸操作，配合apple pencil也可以作为数位板支持压感。\n","path":null},{"url":"https://yzzfo.github.io/blog/自动化玩游戏——模型训练/","title":"自动化玩游戏——模型训练","description":null,"body":"在搭建了Yolo环境后我们就需要训练自己的模型了，这是一个费时的事情，但我们可以通过某些方式来加快他的进程。\n训练基础模型\n训练基础模型的方法可以参考自动化玩游戏——Yolo一文中的内容\n使用基础模型生成带标注的数据\n\n使用labelimg编辑自动标注的文件\n用labelimg打开刚刚训练出的文件夹，对里面的标注进行纠正，也可以少量修正，训练时可用于增强模型的泛用性\n使用新数据训练新模型\n将刚刚新生成的数据加入数据集中，重新训练模型，循环往复即可\n参考\n\nPretrain YOLOv8 with semi-supervised learning\n\n","path":null},{"url":"https://yzzfo.github.io/blog/自动化玩游戏——Yolo/","title":"自动化玩游戏——搭建Yolo环境","description":null,"body":"Yolo现在主流有v5和v8两者在使用上还是有点差别的，v8整体来看比v5现代化许多。\n搭建v5\n由于v8中有些知识依赖v5，所以先搭建一个v5环境。\n\n训练模型\n经过上面的命令yolov5环境就算搭建好了，接下来就是训练模型。\n\n编辑标签文件\n在datas目录下有很多的yaml文件，以coco.yaml文件为例，我们需要在里面定义编号以及对应的名称。\n\n\n\n上面的yaml定义了train和val目录，yolo训练的时候会自动将images改为lables然后再里面去查找对应的标签。\n\n标记图片\n标记图片使用labelimg\n执行训练\n\n\n使用模型\n\n搭建v8\n\npip install ultralytics\n同v5中的datasets结构一致搭建数据集，并创建coco.yaml\n训练yolo train data=coco8.yaml model=yolov8n.pt epochs=10 lr0=0.01\n导出onnxyolo export model=yolov8n-cls.pt format=onnx\n\n使用模型\n\n在Rust中使用Yolov8模型\n  参考YOLOv8-ONNXRuntime-Rust\n\n安装onnxruntime环境，在Win11中默认的版本可能过低需要去下载新的onnxruntime\n查阅文档，看个版本支持的Cuda版本，例如此时1.18.1需要Cuda 12.x，cuDNN 9.x  ，下载后将dll放入rust工程根目录，同时安装对应版本的Cuda和cuDNN，两者都需要，否则可能导致onnx无法使用Cuda执行。\n编写build.rs\n\n\nYOLOv8-ONNXRuntime-Rust的作者的更新基本在usls，可参考该处看更多内容。\n","path":null},{"url":"https://yzzfo.github.io/blog/自动化玩游戏——输入控制/","title":"自动化玩游戏——输入控制","description":null,"body":"  最近在制作自动搬砖的程序时遇到程序发送的输入事件游戏无法接收到，在查阅了相关资料后发现这应该是由于游戏是直接使用dx直接读取的信号输入，没有经过系统的信号输入事件，而通常的输入库只是往系统输入事件中发送消息，所以导致游戏无法读取到程序发送的输入事件。经过一番搜索找到如下几个库对其作了相应处理。\n\nhttps://github.com/ReggX/pydirectinput_rgx\nhttps://github.com/pentamassiv/enigo/tree/win_respect_lang\nhttps://raw.githubusercontent.com/SilverComet7/yolov5-DNF/main/directkeys.py\n这两个库都在发送系统消息的同时也发送ScanCode，通过这种方式来解决输入问题\n\n在使用这些库的同时还需要管理员权限运行才能正常获取到输入\n参考资料\n\nhttps://www.bilibili.com/read/cv13574363/\n\n","path":null},{"url":"https://yzzfo.github.io/blog/在Unity中实现Illustrator中的文本排版/","title":"在Unity中实现Illustrator中的文本排版","description":null,"body":"最近需要在Unity中实现和Illustrator中一样的文本渲染效果，但Unity的TextMeshPro和Illustrator差别还是蛮大的，所以在这记录一下相关的内容。\n\n在横版的情况下\n如何确定字体高度\n  有时候我们将fontSize设置为12px的时候却发现他的preferHeight却是14px，那么这是怎么来的呢？为了明白这个问题，我们需要先知道字体中的三个基础属性:\n\nUPM：Units per Em，通常为1000，fontSize将对应该值，可以理解为标准字体大小\nAscent: 上界距离基线的距离\nDescent: 下界距离基线的距离\n\nAscent与Descent组合在一起用于确定字体最大的高度Height=Ascent-Descent，preferHeight对应该值。所以可以得到height_px = Height / UPM * fontsize_px，这点在Unity和Illustrator中是一致的。\n例如：UPM=1000，Ascent：852 Descent：-248 ，那我们可以知道该字体大小为  (852+248)/1000 = 1.1 em即当fontSize设置为10pt的时候，他实际大小为11pt。\n如何确定字体宽度\n  宽度和高度基本同理，但宽度的数据在每个字的内部，即Width=glyph.metrics.horizontalAdvance。  width_px = Width / UPM * fontsize_px\n如何确定字体位置\n  确定了字体大小也只是确定了包围盒,但位置并不知道，他以哪个地方为锚点开始画也不知道，这个时候就轮到了baseline这个属性，根据公式Top = (Ascent-baseline)/Height和Bottom = (baseline-Descent)/Height，可以算出baseline所在的位置，bottom_offset = height_px * Bottom，从底部向上偏移bottom_offset这么多就是baseline的位置，字体在设计的时候也是根据baseline进行设计的，这样就确定了位置。\n行高\nUnity\n  TextMeshPro LineHeight=0的时候默认使用的是，TextMeshProAsset中的LineHeigt属性以下称为T_LineHeight，T_LineHeight属性单位和Ascent是一样的，所以计算px的算法也是一致的，lineHeight_px = T_LineHeight / UPM * fontSize_px。LineHeight单位为1em/100，即lineHeight_px = T_LineHeight / UPM * fontSize_px + LineHeight * fontSize / 100\nIllustrator\n  行高就是在位置属性中设置的大小，比如12pt那么一行就是12pt，即换行文字向下偏移12pt。\n文字高度\nIllustrator\n文字高度不同于行高（行高指偏移，文字高度指单行时元素高度），此处文字高度指如下图所示的文字框的高度。\n\n下边界\n在Illustrator中，如下思源黑体之所以出现如此大的高度原因在于其字体内存在glyph，该glyph的ymin比Descent更小，因此导致框的下边界下移，即:  若字体中glyph的ymin小于Descent，则导致下边框下移，要解决这种问题可以尝试将哪些过高的glyph删除。\n上边界\n对于上边框，此处采用 https://www.glyphrstudio.com/app/ 该软件中的数值为基准进行计算，影响上边界的属性为Capital letter height，从baseline到上边界的距离符合h = 0.6*fontSize + 0.5*capital_letter_height/UMP，若文本本身高度超过了该计算值，则该值为文本高度。\n总上所述，文字高度总公式为h = 0.6*fontSize + 0.5*capital_letter_height/UMP - Descent/UPM * fontSize,该公式适用于一般不超过默认边界线的文本，若出现超出的字符则按照相应规则对其中的数值进行替换处理。\n踩坑点\n  在探索上边界规则的时候一开始使用的FontCreator来查看修改的字体数据，但其导出的数据似乎存在兼容性等问题有些字体数据符合预期有些又是不符合预期的，导出的字体在glyphrstudio查看数据发现有些字体与修改的数据不一致，通过在glyphrstudio修改数据后在到Illustrator中进行校验才能算出符合预期的结果。How does Illustrator calculate text frame height 这篇文字中指出OS/2相关的数据，也可能是FontCreator中这部分数据存在问题导致输出字体存在差异。\n在竖版的情况\n  竖版情况下Unity和Illustrator兼容的部分相当有限，这里就记录以下每个部分的渲染逻辑。\nIllustrator\n罗马排布形式\n  罗马排布形式即字母符号不会旋转90度。\n文字高度/行高\n文字大小依赖如下属性:\n\nUPM\nglyphRect\n\n利用UPM来算出字体高度的最小值，glyphRect算出实际高度，例如j会比UMP大一些，a比UMP小，此时得到的高度a为UPM，j为glyphRect算出的高度，换而言之渲染时若字符小于1em则让其占用1em高度，若大于1em，则按实际高度。\n例外，若有字体中有Vertical属性，就以(Vertical_Ascent - Vertical_Descent)为基准。\n非罗马排布\n文字高度/行高\n同罗马排布形式，但区别在于字母和符号，因为会旋转所以长宽需要互换。\n行距\n行距离1000为1em，例如fontSize=12pt，1000即为12pt。\nUnity\n  Unity本质上是没竖版这类型的，可以单字绘制，大小和位置可以通过模仿Illustrator中规则来进行制作。\n其他\nUnity和Illustrator读取的字体属性可能不一致，有时候例如思源黑体，Unity中的字要比Illustrator中大的多，在FontCreator查看可以发现，思源黑体的Typo Ascender和Ascender数值不一样，AI和Unity应该是读取了不同的属性导致两者发生差距，在手动修改Unity的Asset值后，AI与Unity的字体可以一致显示，或者在FontCreator中修改两者的属性值。Illustrator用的Typo Ascender\n工具\n\nhttps://vertical-metrics.netlify.app/\nhttps://www.glyphrstudio.com/app/\n\n参考资料\n\nhttps://paddywang.github.io/demo/list/css/baseline_line-height.html\n\n","path":null},{"url":"https://yzzfo.github.io/blog/13代Intel-PVE直通/","title":"13代Intel PVE直通","description":null,"body":"下面是教程，主要说关于UHD770，或者叫10代-13代核显的直通教程：\n前言\n在创建win10虚拟机里面请选择默认 ovmf+i440fx 7.2版本或者最新以上机型（不能选q35！QEMU不支持Q35 核显Legacy模式下显示，可以定制QEMU支持Q35，不在本文讨论）\nbios选择ovmf（BIOS必须OVMF，Intel核显已不支持传统BIOS启动）。添加sriov设备的时候，勾选pcie和主gpu，勾了主gpu之后，pve就不会显示画面了，可以尝试吧显卡改成virtio-gpu，这样就可以显示控制台。如果装驱动43，把显示该成无（none）。\n虚拟机内存至少4G\n客户端选 win10 不要选 win11 （用Win11 i7-13620h成功测试）\n下载资源\nhttps://www.123pan.com/s/20P0Vv-yxd6H.html\n提取码:mura\n备份资源： https://github.com/Cnicehs/igd ， 可以直接使用 2in1_rom/igd_rpls.rom 这个rom\n下载后解压，具体如何使用，详细参考其中的readme文件\n重点其实就是两个文件：gen12_igd.rom和gen12_gop.rom，10-13代核显可以直接把这两个放进 pve 的\n/usr/share/kvm\n路径下即可\n注：本资源来自于：https://github.com/gangqizai/igd，感谢原作者复出，本次仅做搬运，转载请注明出处！\nbios设置\n虚拟化vtd vtx 多线程\n开启iommu\n关闭CSM尽量只用UEFI\n注意BIOS设定：DVMT pre allocated，不要大过64M，64M对应x-igd-gms=0x2，如果超过64M,x-igd-gms要加大！\n开始PVE配置：\n换源\n执行\napt install apt-transport-https ca-certificates\n先更改\nvi /etc/apt/sources.list\n原来的注释或全部删除，用下面的代替\n8.0清华源\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware\nsecurity updates\ndeb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware\n更改\nvi /etc/apt/sources.list.d/pve-enterprise.list\n用下面的代替\n8.0\ndeb https://mirrors.tuna.tsinghua.edu.cn/proxmox/debian bookworm pve-no-subscription\nPVE8还需要改一下ceph\nvi /etc/apt/sources.list.d/ceph.list\n修改：\ndeb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-quincy bookworm no-subscription\n最后更新一下：\napt-get update\npvetools\n先删除企业源：\nrm /etc/apt/sources.list.d/pve-enterprise.list\n安装\nexport LC_ALL=en_US.UTF-8\napt update &amp;&amp; apt -y install git &amp;&amp; git clone https://github.com/ivanhao/pvetools.git\n启动工具（cd到目录，启动工具）\ncd ~/pvetools\n./pvetools.sh\n如果你没有外网，需要改为以下命令来运行，搬运：\nexport LC_ALL=en_US.UTF-8\napt update &amp;&amp; apt -y install git &amp;&amp; git clone https://gitee.com/fanjinhong/pvetools8.git\n之后需要改一下权限\ncd ~ &amp;&amp; chmod -R 777 pvetools8\n对应的启动工具（cd到目录，启动工具）\ncd ~/pvetools8\n./pvetools.sh\n注意：不要用“去除订阅提示”，可能有bug，“cpu省电”可能导致cpu性能不足，其余可以适当配置，如无需要不要乱配\n开启IOMMU\n此步骤几乎为必须\n启动内核IOMMU支持\nvi /etc/default/grub\n修改/etc/default/grub，i915.enable_guc=7\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet intel_iommu=on iommu=pt initcall_blacklist=sysfb_init multifunction pcie_acs_override=downstream i915.enable_guc=7\"\nupdate-grub\n屏蔽驱动\nvi /etc/modprobe.d/blacklist.conf\n添加内容\nblock AMD driver\nblacklist radeon\nblacklist amdgpu\nblock NVIDIA driver\nblacklist nouveau\nblacklist nvidia\nblacklist nvidiafb\nblock INTEL driver\nblacklist snd_hda_intel\nblacklist snd_hda_codec_hdmi\nblacklist i915\noptions vfio_iommu_type1 allow_unsafe_interrupts=1\n屏蔽三大显卡驱动，屏蔽hdmi声音驱动；options vfio_iommu_type1 allow_unsafe_interrupts=1 允许不安全的设备中断\nupdate-initramfs -u -k all\n增加module\nvi /etc/modules\n然后添加\nvfio\nvfio_iommu_type1\nvfio_pci\nvfio_virqfd\n将设备加入进vfio\n找到id\nlspci -D -nnk | grep VGA\n得到\n0000:00:02.0 VGA compatible controller [0300]: Intel Corporation Alder Lake-S GT1 [UHD Graphics 770] [8086:4690] (rev 0c)\n0000:03:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 23 [Radeon RX 6600/6600 XT/6600M] [1002:73ff] (rev c7)\nid就是（12代UHD770基本都是这个代号）\n8086:4690\n用于添加直通组\nvim /etc/modprobe.d/vfio.conf\n改为（vifo.conf 没有 disable_vga=1，有的删掉！）\noptions vfio-pci ids=8086:4690\nupdate-initramfs -u\n虚拟机配置（这个才是重点）\n具体根据自己的虚拟机来配置\nvim /etc/pve/qemu-server/100.conf\n给出示例：注意仅做参考，前面是行号\n1 agent: 1\n2 args: -set device.hostpci0.addr=02.0 -set device.hostpci0.x-igd-gms=0x2 -set device.hostpci0.x-igd-opregion=on -debugcon file:/root/igd_debug.log     -global isa-debugcon.iobase=0x402\n3 balloon: 0\n4 bios: ovmf\n5 boot: order=sata0;ide0\n6 cores: 4\n7 cpu: host\n8 efidisk0: local-lvm:vm-100-disk-0,efitype=4m,size=4M\n9 hostpci0: 0000:00:02.0,legacy-igd=1,romfile=gen12_igd.rom\n10 hostpci1: 0000:00:1f.3,romfile=gen12_gop.rom\n11 ide0: local:iso/virtio-win-0.1.229.iso,media=cdrom,size=522284K\n12 machine: pc-i440fx-8.0\n13 memory: 4096\n14 meta: creation-qemu=8.0.2,ctime=1692294184\n15 name: wintest\n16 net0: virtio=7A:1E:CC:A8:81:D2,bridge=vmbr0,firewall=1\n17 numa: 1\n18 ostype: win10\n19 sata0: local-lvm:vm-100-disk-1,size=40G,ssd=1\n20 scsihw: virtio-scsi-single\n21 smbios1: uuid=adaf615c-2ff8-43a9-b8f5-6433e379aa6d\n22 sockets: 1\n23 usb0: host=062a:4101,usb3=1\n24 usb1: host=1a81:1202,usb3=1\n25 vga: none\n26 vmgenid: 69c57031-908b-4795-a197-215c209e43e2\n这里面的重点是：2、 9 、10 、25行\n2 args: -set device.hostpci0.addr=02.0 -set device.hostpci0.x-igd-gms=0x2 -set device.hostpci0.x-igd-opregion=on -debugcon file:/root/igd_debug.log     -global isa-debugcon.iobase=0x402\n9 hostpci0: 0000:00:02.0,legacy-igd=1,romfile=gen12_igd.rom\n10 hostpci1: 0000:00:1f.3,romfile=gen12_gop.rom\n25 vga: none\n之后需要自己用工具，把两个文件，通过sftp等方式，放进pve下的 /usr/share/kvm/下\n然后需要自行安装驱动才能真正运行正常\n安装驱动：最好是用Windows更新来安装，实在不行，可以从下面二选一：\nhttps://www.intel.cn/content/www/cn/zh/download/729157/intel-arc-iris-xe-graphics-beta-windows.html\nhttps://www.intel.cn/content/www/cn/zh/download/785597/intel-arc-iris-xe-graphics-windows.html?\n捡垃圾、黑苹果、瞎吹牛逼QQ群：805190737\n","path":null},{"url":"https://yzzfo.github.io/blog/Rust调用C-Cpp/","title":"Rust调用C/C++","description":null,"body":"编写C代码\n\n\n编写Rust绑定代码\n\n\n\n若头文件很多，也可以写一个wrapper.h\n\n\n\n至此，Rust即可使用 C header中的方法了\n关于.a和.o等文件\n.o 文件\n\n用途：这是目标文件，由编译器从 .c 或 .cpp 源文件生成。目标文件包含机器代码，但尚未链接成可执行文件或库。链接器会将多个 .o 文件和库文件链接在一起生成最终的可执行文件或库。\n内容：编译后的机器代码和必要的符号信息。\n\n.a 文件\n\n用途：这是静态库文件，包含了一个或多个 .o 文件的集合。静态库在链接阶段被包含到最终的可执行文件中。与共享库不同，静态库在链接之后不需要随可执行文件一起分发。\n内容：一个或多个 .o 文件的打包，通常用 ar 工具创建。\n\n关于Wasm\n在不使用C/C++的时候，rust可以直接通过wasm-pack来编译出wasm，但在依赖C/C++时且用到类似stdlib的时候则无法编译通过，因为wasm-pack没有默认的标准库，这时候需要使用emscripten 即 cargo build --target wasm32-unknown-emscripten  --release\nemscripten\n在emscripten中很多指令和gcc类似，例如ar,dump等等，对应的指令为emar,emdump\n安装emscripten\n\n以下是一个symbol去重的简易脚本，在特定情况下可以用于去重\n\n下面是一个用于重命名的脚本，用于对C/C++进行重命名，会将文件夹/文件中特定字符串替换掉\n\n在Unity中配置emscripten\n通过类似如下方式可以添加编译时参数\n\n内存超出\nRuntimeError: memory access out of bounds，出现类似报错，可能需要添加-s TOTAL_STACK=512mb,即类似如下指令emcc hello.cpp .\\target\\wasm32-unknown-emscripten\\release\\libkxttest.a -o output.html -s TOTAL_STACK=512mb\n","path":null},{"url":"https://yzzfo.github.io/blog/Thread模型/","title":"Thread模型","description":null,"body":"  在使用slint构建出应用后导出ffi给C#的Console程序调用时出现了类似Make sure other crates are not using multithreaded COM这样的报错，问题原因如下。\n以下为ChatGPT的答案:\n在C#调用Rust提供的FFI（外部函数接口）时遇到“Make sure other crates are not using multithreaded COM”这样的报错，通常是因为在使用COM（Component Object Model）组件时出现了线程模型不匹配的问题。\n了解COM的线程模型\nCOM有两种主要的线程模型：\n\n单线程单元（STA，Single-Threaded Apartment）：适用于需要单线程访问的COM对象。通常由UI线程使用。\n多线程单元（MTA，Multi-Threaded Apartment）：适用于可以被多个线程安全访问的COM对象。\n\n当在一个应用程序中使用COM时，需要确保所有使用COM的部分遵循同样的线程模型。如果在Rust中某些部分使用了MTA，而C#调用部分期望STA，这会导致线程模型不匹配，从而引发错误。\n解决方案\n\n\n确保线程模型一致：\n\n\n如果C#代码在STA线程中运行，确保Rust代码也在相同的线程模型下工作。\n\n\n可以通过设置C#代码的线程模型来确保一致性：\n\n\n\n\n\nRust中的COM初始化：\n\n\n在Rust代码中使用com库时，需要确保正确设置COM的线程模型。例如，使用CoInitializeEx函数初始化COM库时，指定正确的线程模型：\n\n\n\n\n\n确保无冲突的COM使用：\n\n如果项目中有多个crate在使用COM，确保这些crate之间的COM初始化和使用没有冲突。如果可能，尝试将COM初始化和使用集中在一个crate或一个模块中。\n\n\n\n检查其他可能的原因\n\n引用的第三方库：检查是否有其他引用的第三方库在后台使用了多线程的COM模型。必要时，阅读这些库的文档和源码以了解它们的COM使用方式。\n跨线程COM对象访问：确保没有在STA和MTA之间跨线程访问COM对象的情况。COM对象在不同线程模型之间跨线程访问时，需要进行适当的封送（marshalling）。\n\n总结\n这个错误提示通常是由于C#和Rust代码中的COM使用不一致导致的。通过确保所有部分使用一致的线程模型，并正确初始化COM，可以避免这个问题。如果需要更多详细信息，请提供相关代码片段，以便提供更具体的建议。\n在C#中创建STA线程\n\n经过验证\n可以通过如下几种方式实现Console ffi调用ui\nRust线程启动UI\n通过Rust的thread启动ui线程以正常启动，C#中只需要正常调用ss()即可打开窗口\n\nC#使用STA\n此时rust可以不用写thread相关代码调用ui，通过在CSharp中设置STA即可正常调用ss()\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/纹理压缩/","title":"纹理压缩","description":null,"body":"在Unity中直接载入png,jpg之类图片的时候对内存的压力是很大的，在Android和IOS可以使用astc格式，win下则可以使用dxt格式格式进行内存压缩，在使用3000x8000图片的时候能将内存从100M降低到10M左右。\nASTC\n从https://github.com/ARM-software/astc-encoder下载相应软件后执行类似./astcenc-avx2.exe -cl ./测试.png test.astc 8x8 -medium -yflip指令即可生成astc图片，-yflip用于翻转图片以适应Unity。\nASTC的前16字节用于描述该图片的信息\n\n通过dim_x和dim_y即可获得图片尺寸(小端字节序)\nwidth = dim_x[0] + (dim_x[1] &lt;&lt; 8) + (dim_x[2] &lt;&lt; 16);\nheight = dim_y[0] + (dim_y[1] &lt;&lt; 8) + (dim_y[2] &lt;&lt; 16);\n在Unity中载入ASTC需要剔除文件头(16字节Loading ASTC texture from file)\n\nDXT\n下载https://github.com/FrozenStormInteractive/Crunch2，通过如下命令crunch -file blah.tga -fileformat dds -dxt1 -mipmode none生成dxt文件\n\n参考\nhttps://discussions.unity.com/t/can-you-load-dds-textures-during-runtime/84192/2\nhttps://stackoverflow.com/questions/25402080/does-endianness-apply-to-bit-order-too\nhttps://huailiang.github.io/blog/2022/astc/\nhttps://forum.unity.com/threads/loading-astc-texture-from-file.945125/\nhttps://dench.flatlib.jp/ddsformat\ndds_texture_loader.c\n","path":null},{"url":"https://yzzfo.github.io/blog/测试网络状况的方法/","title":"测试网络状况的方法","description":null,"body":"在使用代理的时候会需要对他们进行一些测试来看看他们的效果如何，通常诸如ping或tcping之类的手段也只能去简单测试他们的连接速度，在使用tun模式的时候大部分情况下也只能使用软件自带的tcping进行简单测速（类似nekoray不支持hysteria2进行tcping测试），ping则无法通过tun进行转发从而导致无法使用。\n当我们想测试一下当前客户端到服务器的网络波动以及速度的时候上面的方法自然无法满足，这个时候我们可以通过iperf3来进行测试，通过在服务器运行iperf3，客户端代理本地iperf3则可以用于测试客户端到服务器直接的网络质量。\n\n通过这种测试方法也可以推测出代理针对不同流量所使用的策略，例如vless协议中代理udp是走的udp over tcp所以在iperf3的测试中udp丢包为0，但客户端测试使用hysteria2转发udp的时候出现了丢包，而当服务器也走该代理且运行客户端同样的指令时却没出现丢包，通过这两点推测hysteria2通过修改quic协议在处理udp转发的包的时候使用的不可靠传输模式即不对udp的转发包进行重传之类的，类似于udp直连，这也导致出现了丢包的情况。和shadow sock中对待udp类似。\n","path":null},{"url":"https://yzzfo.github.io/blog/Linux下代理终端/","title":"Linux下代理终端","description":null,"body":"在Linux中通常要代理诸如curl或者wget之类的指令使用,export HTTP_PROXY=xxxx和export HTTPS_PROXY=xxxx即可，但对于其他的执行这些方式则可能就没效果了。\n在Ubuntu中可以通过安装proxychains4来实现代理效果。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/win中的eol问题/","title":"win中的eol问题","description":null,"body":"在Windows系统下文件结尾默认为/r/n即CRLF，但Linux下却是/n即LF这点差异在一般的文本文件中到没什么问题会出现，但对于shell脚本，由于/r/n的出现，会导致其无法运行，对于简单的复制脚本到Linux，可以使用dos2unix命令来对文件进行转换，但如果使用devContainer来开发程序那就不可避免的要进行一番设置了。\n\n将vscode设置为LF结尾，在设置中搜索eol将其设置为\\n即可。\ngit仓库进行reset，使其回归\\n结尾\n\n\n这样在devContainer中打开文件就说LF结尾的了。\ncore.autocrlf\ncore.autocrlf这个值为true的时候 git仓库中存的都是LF结尾的文件，当拉取的时候git会判断平台将文件的结尾进行对于更改。\n为了使win下也是LF，所以需要将他设为false，这样就能使用原始文件结尾了。\n","path":null},{"url":"https://yzzfo.github.io/blog/使用Dnsmasq来让host通过名称访问Docker/","title":"使用Dnsmasq来让host通过名称访问Docker","description":null,"body":"  最近在使用Docker的时候遇到了这种问题，首先我想让这个容器能够自由的开放端口供外部访问(例如V2ray的管理面板)，其二我还需要访问其他容器例如(Nginx Proxy)，要完成第一个任务通常使用host模式即可，完成第二件事通常就是创建一个功能的network接口，所有容器都使用这个network接口互相通过域名访问。但现在遇到的需求则是需要同时满足两者的特性，这时候我们可以通过使用Dnsmasq来实现这个。\n思路\n配置Dnsmasq容器jpillora/dnsmasq，让其开放53端口供外部访问，同时使用一个network接口A，其他的容器例如alist,webdav这类希望通过反代访问的容器，也使用network A接口，这样在dnsmasq中我们便能通过容器名称访问到这些容器了，但在默认情况下改容器的/etc/resolv.conf并未配置正常的DNS可以用于解析外部域名例如google.com，所以需要在里面加上一条nameserver 1.1.1.1这样改容器自身便能进行DNS解析了，之后配置Dnsmasq，no-resolv要删除，仅保留server=127.0.0.11这一个server，其他server都删除，这样便配置完成了。\n第二步，设置我们的目标容器为host模式，这样我们便能够自由开放端口，为了通过名称访问其他的容器，我们还需要让本机的dns解析走Dnsmasq去解析，参考设置DNS进行DNS设置，这样我们在宿主机便能通过容器名称访问容器了。\n整体DNS解析流程类似这样\n\nAdguard\n当使用Dnsmasq时若遇到查询不存在的容器名称时会导致出现DNS查询的死循环，其提供的dns-loop-detect使用后又无法查找本地的DNS，在改为使用Adguard后可以解决这个问题，原理和之前的Dnsmasq一样,DNS中添加127.0.0.11(11为Docker内置的DNS),但在设置时需要选择最快的IP地址这个DNS查询选项，只有这个才能保证Adguard在查询时会去调用127.0.0.11,其他两个选择不能确保必定走127.0.0.11进行查询。\nDnsmasq和Adguard组合\n  最近在使用qbittorent的是否发现docker-proxy内存占用过高了，参考这个教程,进行了一下排查发现是adguard导致的，重启几次后发现他的内存占用还是缓慢上升，估计是产生了类似dnsmasq的循环查询导致的，将其改为并发查询后内存有所缓解，但依旧还是维持在比较高的水平，再将127.0.0.11:53给删除之后重启，内存保存在了正常水平，为了解决host模式下解析容器ip的问题最终选择采用adguard+dnsmasq的形式。\n排查时使用的命令\n\nadguard+dnsmasq 结构拓扑\n在宿主机容器中修改resolve.conf或者对特定程序例如nginx在解析时指定127.0.0.2时即可\n\n参考资料\nhow does Docker Embedded DNS resolver work?\n","path":null},{"url":"https://yzzfo.github.io/blog/OpenGL笔记/","title":"OpenGL笔记","description":null,"body":"  OpenGL在设计上是一个状态机，所以在使用的时候大部分API都是进行一种状态操作。\nVBO和VAO\nVBO是vertex buffer object用于存储从CPU传过来的数据\nVAO是vertex array object用于解释VBO的一个数据结构\n申请VBO和VAO\n\n通过api我们向opengl申请VBO和VAO对象，他返回了两个id用于代表对象。\n赋值\n申请到了对象之后自然需要给他们输入一些数据\n\n\nVBO\n由于OpenGL是一个状态机，我们想象他身上有很多的插槽，其中GL_ARRAY_BUFFER就是放置VBO的槽位，我们使用glBindBuffer(GL_ARRAY_BUFFER, vbo_id)将我们刚刚申请的VBO放在里面，然后通过glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW)告诉OpenGL我们要将vertices放到VBO的槽里面去，这样就完成了赋值操作。\nVAO\nVAO结构\nVBO只不过是CPU中传过来的一串数组而已，OpenGL是无法知道他该如何解析的，这个时候我们需要告诉OpenGL怎么去解析，于是出现了VAO，OpenGL是认得VAO的，我们需要告诉OpenGL怎么把VBO映射到VAO中，在这之前需要说明一下VAO中的数据结构。\nVAO由许多个槽位构成，用户可以通过API将VBO中的数据映射到不同的槽位中，通常VAO支持16个槽位，可以通过如下代码获取最大值。\n\nVAO赋值\n通过glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *) (3 * sizeof(float))); 这句话告诉OpenGL，你应该每8个float为一组的去读VBO中的数据，这8个数据中要跳过前3个，之后的3个数据就是槽位1所需要的数据。\n对于VAO也是类似VBO中的操作，通过glBindVertexArray(vao_id)将其绑定到VAO的槽中。通过glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void *) (3 * sizeof(float)))对VAO槽中结构体的第一个槽写入读取规则，glEnableVertexAttribArray(1)启用VAO槽中结构体的第一个槽。\nShader\n编写Shader\n\n\n使用Shader\n\n绘制\n\nEBO\n在使用纯VBO进行绘制的时候我们会发现当我们使用三角面绘制四边形的时候需要用到6个点，这显然出现了浪费，于是我们将顶点数据和三角形数据进行分离，即VBO中保存的是顶点数据，EBO中保存顶点索引，例如\n\n通过如下方式使用EBO，用法和VBO差不多\n\n绘制\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Blender导出模型到Unity/","title":"Blender导出模型到Unity","description":null,"body":"坐标系\n右手系\n\nBlender中X对应right，-Y对应forward，Z对应up\nObj，X对应right，Y对应up，-Z对应forward\n\nFBX\nFBX SDK中存在几种不同的坐标系，在Blender导出时默认和Obj是一样的坐标系(X对应right，Y对应up，-Z对应forward)\n左手系\n\nUnity中X对应right，Y对应up，z对应forward\n\n导出设置\nObj\n在Blender导出obj时需要将Forward Axis设置为-Z，Up Axis设置为Y，对应Obj格式的要求，这样便会将Blender中的-Y对应到Obj文件中的-Z，Z对应到Obj中的Y。\nFBX\n在Blender导出fbx时需要将Forward Axis设置为-Z，Up Axis设置为Y，对应FBX格式的要求，同时需要Apply Transform，若未Apply Transform则在Unity中会出现绕X选择-90。\n或者使用插件进行导出 https://github.com/EdyJ/blender-to-unity-fbx-exporter\n","path":null},{"url":"https://yzzfo.github.io/blog/OpenGL环境搭建/","title":"OpenGL环境搭建","description":null,"body":"开发环境\n\nWin11\nVisual Studio 2022\nHelix\n\n环境搭建\n安装\n\n下载cmake并加入环境变量中\n安装LLVM，用于获得clangd使得helix中的支持cpp代码提示\n\n项目配置\n\n\n下载glfw和glew，解压至third文件夹中\n编写CMakeLists.txt文件\n\n\n\nCMake\n此时使用Ninja来生成项目(为了生成compile_commands.json，visual studio生成器不支持生成该json文件)，为了生成正确的配置需要执行vcvars64.bat来配置环境编辑，这样生成的配置文件才会正确引用visual studio工具链作为编译工具。\n\nHello World\n\n\n\nCompile\n由于使用Visual Studio工具链，所以需要先设置vs环境变量，运行vcvars64.bat即可\n\n\n\n其他\n也可以通过其他方式替代执行vcvars64.bat，即通过使用Develop Command Prompt for VS 2022这个终端，在这个终端中关于vs的环境变量全部都已经加载好了，直接使用即可。\n\n配置Helix\n新建.helix文件夹，作用类似于.vscoed文件夹\n配置LSP\n覆盖默认cpp的lsp配置，其中--limit-results=0用于禁用返回结果的数量限制(因为GL开头的元素很多，导致超出了最大数量限制，进而导致代码提示不全)。  --fallback-style=Microsoft用于配置代码格式化为Microsoft的规则。\n\n配置Config\n\n","path":null},{"url":"https://yzzfo.github.io/blog/tauri笔记/","title":"tauri笔记","description":null,"body":"安装使用\n\nHow to\n\n\n使用Buffer\nBuffer默认是nodejs的全局模块，诸如Buffer.from这种函数在browser中是不存在的，所以需要通过如下方式来使用，其核心就是在使用前将Buffer注册到global中。\n\n\n\n配置@指向src\n\n\n\n\nhls.js使用tauri-http\n在使用诸如hls.js播放视频的时候，有时候需要设置请求头origin之类的请求头，但在webview所提供的api并不支持这总操作，所以需要使用tauri-http来替换相关的请求逻辑进行修改。\nallowlistconfig\n\nTauriLoader.ts通过该代码将hls.js的请求转为使用tauri-http。\n\n\n\n布局\n\nsticky\n通过sticky可以粘性元素，在超出viewport的时候，该元素将粘附在边缘。元素在viewpoint时margin生效，不在时left这类属性生效，即sticky可以生效的时候margin将无效。\n计算鼠标在元素内的坐标\n\n\n静态载入组件\n对于如下的写法Vite打包后只会生成一个js文件，因为这种import为同步加载，vite将会将他们都打入一个js中\n这种情况下可能导致生成的代码运行时出现SyntaxError: Identifier错误，例如同时使用video.js和hls.js这两个库，则会出现getTextContent重复声明的错误，因为他们两个库中都有getTextContent这个字段，但他们却又在同一个js文件中。\n\n动态载入组件\n对于静态载入时出现的问题，可以通过改为动态载入，这样vite就会将不同的文件打包成不同的js文件\n\n管理员身份运行\nhttps://github.com/tauri-apps/tauri/issues/7173\nBuild.rs\n\nManifest\n\nnon-UTF-8 output\nhttps://github.com/rust-lang/rust/issues/35785\n对于cmd，则需要修改系统为utf8格式，chcp可以查看当前编码，chcp 65001设置当前cmd为utf8\n永久更改 -&gt; 控制面板 -&gt; 区域 -&gt; 管理 -&gt; 更改系统区域设置 勾选utf8即可\n对于link.exe，需要在visual studio中安装英文语言包，卸载中文包，这样link.exe就会输出英文的信息了。\nCommand\nTauri提供的Command，在执行诸如new Command('cmd', [\"/c\", explorer /select,C:/ABC/A B/img.jpg]).spawn()这种存在空格路径的命令时无法正确的选中img.jpg，仅会打开正确的目录，若将C:/ABC/A B/img.jpg加上引号则无法真确解析路径，只会打开文件浏览器，这些异常在正常使用cmd时都是不存在的。为了解决这个问题需要自己实现一个Command来使用。\n\n\ncreation_flags(0x08000000) 意为不弹出cmd界面 https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags  https://stackoverflow.com/questions/60750113/how-do-i-hide-the-console-window-for-a-process-started-with-stdprocesscomman\n若从git bash中启动应用则能直接Command::new(\"mkdir\")之类的指令,原因是mkdir在cmd中是一个指令并非可执行文件  https://github.com/rust-lang/rust/issues/95957\n.current_dir(\"./tmp\") 和 Command::new(\"path_to_exe\")中路径的区别，path_to_exe指当前运行环境下exe的文件路径，current_dir设置的是该exe该在那运行，类似于在./tmp目录下打开vscode。\n\nBuild后打开调试界面\nWeb Console\nhttps://github.com/tauri-apps/tauri/discussions/3059\n修改Cargo.toml\n\nRust Console\nhttps://github.com/tauri-apps/tauri/discussions/4179\nmain.rs  修改cfg_attr\n\nbuild.rs 打印log\nhttps://github.com/rust-lang/cargo/issues/985#issuecomment-1071667472\n\nfs scope开启全部路径\nhttps://github.com/tauri-apps/tauri/discussions/5990\n\"scope\": [\"**\"]\nBase64编码\n在ts中，进行base64编码的函数为atob()但这个函数只接收string，且这个string需要是An ASCII (Latin1) string.   ,但这之中有些坑。\n\nTextEncoder 中的Latin1并不是真的Latin1，而是('ISO-8859-1');//windows-1252  参考  ，所以想通过该方式将byte转换为Latin1并不可行。\n使用String.fromCharCode(...data)方式来获取Latin1，其中data为Uint8Array\n使用Buffer.from(data, 'base64')和buf.toString('base64') 来进行base64相关的操作。\n\nProperty 'value' does not exist on type 'EventTarget'\nhttps://stackoverflow.com/questions/42066421/property-value-does-not-exist-on-type-eventtarget\n需要显示的指定类型例如 (e.target as HTMLTextAreaElement).value\nVue 引用组件\n\n\nVue中全局方法\nhttps://blog.csdn.net/m0_63969219/article/details/124579365\n\n使用\n\n也可以写一个单例用于调用Toast\n\n动画\nhttps://www.yzktw.com.cn/post/836711.html\n\nhttps://blog.csdn.net/qq_43923146/article/details/127510036\n\nVue模板中定义、使用\"临时变量\"\n有时候在模板中循环中，需要去计算一个值，并且多次使用。因为是一个循环，所以不太好使用computed，就不得不需要多次计算\n\n这种情况可以在模板中临时定义一个临时变量\n\n并不是只能使用data-var，这个是随意写的，只是一个承载这个临时变量的载体，你也可以这样写。\n\n在Ts中Vite编译会报错，在&lt;Script&gt;中添加一个同名的变量即可\n","path":null},{"url":"https://yzzfo.github.io/blog/Unity中的颜色空间/","title":"Unity中的颜色空间","description":null,"body":"颜色空间\nGamma\n  由于人眼对于暗色的变化更为敏感，所以在精度有限的情况下会分配更多的有效值用于描述暗部，于是引申出了Gamma颜色空间。通过 y=x^0.45 在x = 0-1范围内，将暗部值精度提升，本质上是对图片进行增亮操作。通常显示器在显示时会进行Gamma解码操作，即y=x^2.2 本质是进行 变暗 操作。\n\nLinear\n线性空间就是Gamma值为 1 的情况，也就没所谓的编码解码的必要了。\nPNG\n  对于PNG这种文件来说，并不关心Gamma或者Linear，他只管保存颜色的数据，至于该颜色数据读取后是该Gamma校正还是直接使用由使用者来决定。\n\n对于颜色(0.5,0.5,0.5)，若使用Gamma编码则其在PNG中的值为(0.73,0.73,0.73)，若使用Linear则依然是(0.5,0.5,0.5)\n在PNG的元数据中可以查看Gamma值，但该值并不是必须保存的，所以在没有Gamma值时并不能判断该图片是否进行过Gamma编码\n\nsRGB\n1996年，微软和惠普一起开发了一种标准sRGB色彩空间。这种标准得到许多业界厂商的支持。sRGB对应的是Gamma0.45所在的空间\nUnity中的颜色空间\nLinear\n\n在Linear Space下，图片导入时若勾选sRGB，则在Shader中使用该图片时会自动进行Gamma校正，即对图片进行变暗操作，使颜色值回归线性，即 (0.73,0.73,0.73) =&gt; (0.5,0.5,0.5)\nShader输出颜色时，Unity会自动进行Gamma编码，即假设当前frag输出(0.5,0.5,0.5)，此时若将其保存到Texture时可以发现存储的值为(0.73,0.73,0.73)，即在Linear Space下，Unity输出的图片为sRGB。\n\nGamma\n\n在Gamma Space下sRGB选项将不会生效，将会按照实际值传入Shader中，若要解码则需要自己在Shader中进行相应操作。\nShader输出时并不会自动转换为sRGB，即frag输出(0.5,0.5,0.5)，Texture中存储的也为(0.5,0.5,0.5)。\n\n\nTexture Setting\n\nAlpha is Transparency\n\n如果指定的 Alpha 通道为透明度 (Transparency)，则启用此属性可扩充颜色并避免边缘上的过滤瑕疵。\n由于勾选后可能会改变图片原本的RGB，所以需要更具情况选择是否启动。\n\n\nFormat\n\n对于Texture的不同设置可以通过断点来具体看看不同设置对应的属性\nhttps://docs.unity3d.com/ScriptReference/Experimental.Rendering.GraphicsFormat.html\n例如RGB16其graphicsFormat: B5G6R5_UNormPack16 ，所以他并不支持sRGB选项，若要正常使用则需要切换格式或者在Shader中手动解码\n\n\n\nColor Property\n在Shader中，Color属性是以sRGB模式传递的，所以在Linear空间下他会自动De-Gamma,SL-PropertiesInPrograms\n\n\n例子\n导入的层级图失效\n\n层级图 每一层对应的R=index x 0.1 G=0.5\nshader中根据G&gt;=0.49，Ceil(R x 10)来判断是否属于层级，以及获取层级\n失败的原因在于，用于导出层级图的Unity项目使用的Gamma Space，而主工程使用的是Linear，new Texture时默认为sRGB，导致图片整体变暗，所以G&gt;=0.49判断条件已然不满足，且后续层级获取也将出现问题，正确方法是new Texture时将linear参数设置为true。\n设置为RGB16时图片变正常了？\n因为在Unity中RGB16不支持sRGB选项，所以使用时自动采用了PNG中的值输入到Shader中，所以正常了。\n\n图片\n\n\n\n\n参考\n\nGamma、Linear、sRGB 和Unity Color Space，你真懂了吗？\nGamma空间和Linear空间 全解析\n\n","path":null},{"url":"https://yzzfo.github.io/blog/跨域/","title":"跨域","description":null,"body":"今天想用 video.js 来解决一下昨天爬取到的视频链接，结果遇到了跨域的问题，所以记录一下。\n发生的条件\n\n\n不同域名：当你从一个域名（例如www.example.com）发起请求，而目标资源的域名与之不同（例如api.example.com），就会发生跨域请求。\n\n\n不同子域：即使两个域名在根域上相同，但如果它们的子域不同，仍然会被视为跨域请求。例如，sub1.example.com向sub2.example.com发起请求，就会触发跨域请求。\n\n\n不同协议：当你从一个域名使用不同的协议（例如http://example.com和https://example.com）发起请求，会被视为跨域请求。\n\n\n不同端口：如果请求和目标资源使用不同的端口号，例如一个在http://example.com:8080，另一个在http://example.com:3000，会触发跨域请求。\n\n\n响应头\n在处理跨域请求时，服务器可以通过设置响应头来控制允许的跨域访问。以下是一些常见的跨域相关响应头：\n\n\nAccess-Control-Allow-Origin：该头字段指定允许访问该资源的来源（域名）。例如，Access-Control-Allow-Origin: https://example.com 表示只允许来自 https://example.com 域的请求访问该资源。如果要允许任意来源访问，可以设置为 Access-Control-Allow-Origin: *。\n\n\nAccess-Control-Allow-Methods：该头字段指定允许的跨域请求方法（HTTP 方法）。例如，Access-Control-Allow-Methods: GET, POST, OPTIONS 表示允许使用 GET、POST 和 OPTIONS 方法进行跨域请求。\n\n\nAccess-Control-Allow-Headers：该头字段指定允许的请求头。例如，Access-Control-Allow-Headers: Content-Type, Authorization 表示允许包含 Content-Type 和 Authorization 请求头的跨域请求。\n\n\nAccess-Control-Expose-Headers：该头字段指定允许暴露给客户端的响应头。默认情况下，XMLHttpRequest 对象只能访问特定的响应头字段，如 Cache-Control、Content-Language、Content-Type、Expires、Last-Modified 等。通过设置 Access-Control-Expose-Headers，可以将其他自定义的响应头字段暴露给客户端。\n\n\nAccess-Control-Allow-Credentials：该头字段指定是否允许发送身份凭证（例如 Cookie、HTTP 认证等）到跨域请求的目标服务器。如果需要发送凭证，可以设置为 Access-Control-Allow-Credentials: true。\n\n\n预检请求\n在进行跨域请求时，浏览器可能会发送一个预检请求（Preflight Request）以验证目标服务器是否允许实际请求的发送。这个预检请求使用 HTTP 方法 OPTIONS，并包含一组特定的请求头。\n预检请求的目的是让服务器确认跨域请求是安全和可接受的。服务器在预检请求的响应中指定了允许的请求方法、请求头和其他相关信息，以便浏览器知道实际请求是否可以发送。这种机制可以帮助防止潜在的安全风险，确保跨域请求的可控性和安全性。\n预检请求的过程如下：\n\n\n浏览器发送一个 OPTIONS 方法的请求到目标服务器，包含以下头字段：\n\nAccess-Control-Request-Method：指定实际请求将使用的 HTTP 方法。\nAccess-Control-Request-Headers：指定实际请求将携带的自定义请求头。\n\n\n\n目标服务器收到预检请求后，进行验证和处理。服务器可以检查预检请求中的头字段，确定是否允许实际请求的发送。\n\n\n目标服务器返回一个带有特定响应头的响应，包括：\n\nAccess-Control-Allow-Origin：指定允许访问该资源的来源（域名）。\nAccess-Control-Allow-Methods：指定允许的请求方法。\nAccess-Control-Allow-Headers：指定允许的请求头。\nAccess-Control-Allow-Credentials：指定是否允许发送身份凭证。\n其他相关的响应头。\n\n\n\n浏览器收到预检请求的响应后，检查响应头，确定实际请求是否可以发送。如果预检请求的响应满足要求，浏览器会发送实际请求，携带相应的请求头和数据。\n\n\n预检请求的目的是为了与服务器进行交互，并获取服务器对跨域请求的验证和允许配置。这样可以确保服务器有明确的控制权，从而防止潜在的安全问题和滥用。\n常见禁止设置的请求头\n在跨域请求中，存在一些请求头字段被浏览器禁止设置。这是出于安全考虑，以防止恶意网站滥用跨域请求来访问敏感信息或执行恶意操作。\n以下是一些常见的跨域情况下禁止设置的请求头字段：\n\n\nOrigin：浏览器自动设置的请求头字段，指示请求的来源（域名）。在跨域请求中，浏览器会自动发送 Origin 头字段，但无法手动设置该字段的值。\n\n\nReferer：请求头字段指示请求的来源页面 URL。在跨域请求中，大多数浏览器会限制手动设置 Referer 头字段的值，以保护用户的隐私。\n\n\nCookie：跨域请求默认不会携带当前域的 Cookie。虽然某些情况下可以设置 withCredentials 为 true，以允许发送当前域的 Cookie，但在跨域情况下，手动设置 Cookie 头字段是被禁止的。\n\n\nAuthorization：该请求头字段用于携带身份验证凭据，如令牌或用户名/密码。在跨域请求中，手动设置 Authorization 头字段通常是不允许的。\n\n\n这些是常见的被浏览器禁止设置的请求头字段。如果尝试设置这些字段，浏览器会拒绝该请求并抛出错误。这种限制是为了保护用户数据和确保安全性。\n例子\n\nVideo.js 设置请求头的方法\n\n","path":null},{"url":"https://yzzfo.github.io/blog/在Drone中使用Cache/","title":"在Drone中使用Cache","description":null,"body":"由于 drone 的管线基于 docker，在每次运行时都是一个全新的环境，但可以通过缓存每次必要步骤中的数据来加速诸如编译之类的速度。\n\ndrone 默认情况下所有容器均共享 /drone/src/ 这个路径，这路径也是当前仓库的所在地，也是每个 step 中默认的工作目录。\ndrillster/drone-volume-cache 将 /cache 目录映射至持久 volume 中，mount 中所填路径则是，当前 step 中所需要缓存的路径。通常使用 ./xxx，因为 /drone/src 是所有 step 中都共享的目录，若要挂载非 ./xxx 则需要新增 volume 同时将其路径统一映射给所需的 step\n对于 golang，在 Linux 下默认 GOCACHE=\"/root/.cache/go-build\" GOMODCACHE=\"/go/pkg/mod\" 所以在 build 时为了方便缓存，需要在 build step 中将这两个环境变量进行修改，且必须是绝对路径\n\n在文件多了之后 drillster/drone-volume-cache 的 restore 速度变的很慢，关这一个 step 就得几分钟，改为直接挂载缓存目录后速度有显著提示\n\n这样便将缓存原封不动的保存在了宿主机的 /tmp/drone-cache 目录中了，通过将其挂载在 build 中的目录下，使得 build 获得了缓存的加速\n","path":null},{"url":"https://yzzfo.github.io/blog/Linux下的日志/","title":"Linux下的日志","description":null,"body":"今天需要想要查看之前 tg 机器人的日志的时候发现服务器上已经很久没记录日志了，弄了下发现是之前将日志给关闭了，所以这里记录一下日志相关内容。\n禁用 Journal\n参考： https://forums.mageia.org/en/viewtopic.php?f=7&amp;t=6699\n\nsystemctl restart systemd-journald\n这将禁止 Journal 的写入\n查看日志\njournalctl -u unit -n -f 查看Unit最新日志\n-f 或 --follow 选项。这将使 journalctl 命令进入实时模式，不断显示新的日志消息\n","path":null},{"url":"https://yzzfo.github.io/blog/Home-Assistant笔记/","title":"Home Assistant笔记","description":null,"body":"REST API\n参考该篇文章 https://blog.csdn.net/qq_31923639/article/details/130011710\n以下为文章截图，详细说明了各种参数的来源\n\n如果选择的是 设备 选项而不是 调用服务 则里面的配置文件稍有区别, 如下是开灯的配置\n\n对应的 curl 是\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Openwrt中的开机自启/","title":"Openwrt中的开机自启","description":null,"body":"在 OpenWRT 系统内 init 进程被 procd 取代，procd 作为父进程可以监控子进程的状态。一旦子进程退出后即可在某一个时刻尝试进行重启进程。它通过 init 脚本来将进程信息加入到 procd 的数据库中来管理进程启动，这是通过 ubus 总线调用来实现，可以防止进程的重复启动调用. 在 OpenWRT 系统内使用 procd 监控的有 uhttpd, netifd 等。在/etc/init.d/文件夹内的启动文件带有 USE_PROCD=1标志.\n\n\nhttps://blog.csdn.net/u014436243/article/details/119741808\n\n","path":null},{"url":"https://yzzfo.github.io/blog/DNS-Server/","title":"DNS Server","description":null,"body":"在之前弄穿透的时候没找到支持正则表达式的 dns 服务，后来搜了下发现 Coredns，这里记录一下\n\nrewrite name substring prefix.host.com newhost.host.com 该规则能够将查询的域名重写，例如 A.prefix.host.com -&gt; A.newhost.host.com，这样就能将 A.newhost.host.com 的结果用于 A.prefix.host.come `\n运行\n/coredns -conf /etc/coredns/Corefile\n","path":null},{"url":"https://yzzfo.github.io/blog/Frp笔记/","title":"Frp笔记","description":null,"body":"  在很久以前使用过 frp，最近又在服务器上部署了以下，所以记录一下里面的问题。\n协同 Nginx 工作\n由于服务器上同样有 Nginx，所以 80 和 443 自然是不能给 frp 的，但为了使 Frp 能穿透域名服务所以需要在 Nginx 下反代对应域名至 frp 中，在 nginx proxy manager 中可以通过直接声明类似如下的条目来指定匹配的域名  server_name \"~.*-frp\\.host\\.com\"; 该设置将能将该正则表达式匹配到的域名都转发至 frp 中进行穿透。\n穿透内网 Https\nPVE 系统的管理界面是强制 Https 访问的，但这样无法通过 type=http 或 type = https 直接穿透，需要使用插件 https2http 或者 tcp 穿透来解决，但 tcp 需要自己开一个新的端口，为了使用域名又得在 NPM 中单读开启一个反代才能访问，所以不选择 tcp。使用如下的配置方式便可以将内网的 https 服务穿透出去，且对外暴露的是 http 协议，这在 NPM 的视角下也统一了访问端口都是 80。\n\n后续发现 https2http 还是会导致 wss 无法连接，但 Caddy 的 Https 转 Http 不会导致这种情况\nNPS\nnps 也是一个不错的内网穿透工具，相对于 frp 来说他有一个很不错的 UI 管理界面，他还能通过服务端控制内网设备穿透哪一个端口，即在 frp 中需要客户觉得暴露什么端口，但在 nps 中可以由服务端来决定客户端开启什么端口。\n在使用 nps 的时候发现 PVE 穿透会出现 502 的报错，问题应该和 frp 中是一样的，也需要类似 frp 中 https2http 这样的插件才能解决，但 nps 项目以及停更许久所以又改用 frp 了。\n使用 Caddy 将 Https 转为 Http\n\nhttps://forum.proxmox.com/threads/connection-error-401-no-ticket-nginx-reverse-proxy.94158/\n这种方法在本地情况下只能通过 127.0.0.1 访问，即便设置了 host 以及 scheme 只 https 也还是没效果，可能还有别的东西需要设置吧，但在 VPS 上通过 NPM 反代该端口通过 https 进行访问则可以正常进入 PVE 界面。\n\n在 PVE 中，登陆时会发送 Cookie 至服务端，但 Cookie 的发送条件是当前为 https/localhost 才会发送，即该功能是前端限制，故无法通过 nginx 设置 header 解决，可以通过添加证书来处理这个问题。\n","path":null},{"url":"https://yzzfo.github.io/blog/搭建Email-Server/","title":"搭建Email Server","description":null,"body":"Compose\n\n生成相关数据\n生成用户\n\n生成DKIM\n\n文件在 `dms/config/opendkim/keys/mail.txt\n配置 DNS\n\n添加一个 A 记录，名称为 mail, 指向自己服务器的公网 ip\n添加MX记录， 指向邮件服务器域名 mail.[yourdomain], 优先级设置为10\n添加TXT SPF 记录, 可以简单使用: v=spf1 mx -all\n添加 TXT _dmarx 记录, Name 设置为 _dmarc, Content 设置为 v=DMARC1; p=none; pct=100; rua= my@email.com\n添加 TXT DKIM 记录, Name 设置为 mail._domainkey, Content 设置为类似如下内容 textv=DKIM1; h=sha256; k=rsa; p=xxxxxxxxxxxxxxxxxxxxxxxxxxxxx，内容来自 mail.txt `\n\nTLS\n修改 mailserver.env 文件中如下内容，可参考 https://docker-mailserver.github.io/docker-mailserver/edge/config/security/ssl/\n\n重启服务即可\nSPOOF_PROTECTION\n在 mailserver 中存在该选项，默认开启，会导致直接使用邮箱地址为用户名出现拒绝发件的情况。\nPTR 反向解析\n在 VPS 提供商出进行设置，以 Servarica 为例，其在 Hostname 选项的下方提供了一个 PTR 的按钮可进行修改。\n客户端\n在 IOS 或者 Windows 自带的邮件应用中，IMap 协议默认不会发送密码，所以需要在相关的设置中单读设置一下密码才能使用。\n参考资料\n\nhttps://v2rayssr.com/iredmail.html\nhttps://zhuanlan.zhihu.com/p/609639797\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Bat脚本笔记/","title":"Bat脚本笔记","description":null,"body":"基础操作\n\n设置环境变量  set envname=value\n当前目录  %cd%\n发送键盘按键 echo {ENTER} | test.bat，可以用于解开 pasue\ntype input2.txt 查看文件内容\n延时操作，以及后台操作\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Git笔记/","title":"Git笔记","description":null,"body":"保存凭证在本地\n\n查看配置\n\nglobal 配置文件位置在 ~/.gitconfig ,默认凭证保存在 ~/.git-credentials\nlocal 配置文件在 ./.git/config\nLinux 下不同用户权限问题\n\n\nfork其他项目\n\n","path":null},{"url":"https://yzzfo.github.io/blog/用GitAction构建Docker/","title":"用GitAction构建Docker","description":null,"body":"   之前有拿 GitAction 来构建过 Docker，所以在这里重新记录一下。\n这里以 Build webssh 这个项目 为例\n\n","path":null},{"url":"https://yzzfo.github.io/blog/nginx笔记/","title":"nginx笔记","description":null,"body":"在部署 Unity WebGL 的时候遇到一些问题所以记录一下。\n环境\n\nNginx Proxy Manger\n\n添加Header\n\n设置反代超时\n由于 cloudflare 有个 100s 的强制 timeout，所以若使用了 cloudflare 且设置的 timeout 大于 100s，还是会在 100s 就断开。\n\n正则表达式\n在 Nginx 配置文件中，可以使用正则表达式来匹配 URL 或其他文本。以下是 Nginx 中正则表达式的使用示例：\n\n简单的正则表达式匹配\n\n使用 ~ 运算符可以在 Nginx 中使用正则表达式匹配 URL，例如：\n\n在上面的示例中，正则表达式 \\d+ 匹配一个或多个数字，匹配的 URL 将被重定向到该位置。\n\n匹配扩展名\n\n使用 ~ 运算符和 $ 字符可以在 Nginx 中使用正则表达式匹配文件扩展名，例如：\n\n在上面的示例中，正则表达式 \\. 匹配任何字符，. 字符表示点号，jpg$ 匹配 URL 末尾的 .jpg。\n\n命名捕获\n\n使用 location 指令和正则表达式的命名捕获组可以在 Nginx 中捕获 URL 中的特定部分，并将其传递给后端应用程序，例如：\n\n在上面的示例中，(?&lt;username&gt;[a-zA-Z0-9_-]+) 是一个命名捕获组，它匹配 URL 中 /user/ 后面的任何字母、数字、下划线或破折号，并将其保存到名为 username 的变量中。然后，可以使用 $username 变量将该值传递给后端应用程序。\n需要注意的是，在使用正则表达式时，应该谨慎地考虑性能和安全性，并避免在表达式中使用过于复杂的模式。\nlocaltion和if中正则表达式的不同\n在localtion中 / 充当着路径的意思，所以会出现如下问题\n\nurl decode的问题\n在location中匹配的表达式将会被自动url decode 例如/cors/https://example.com/A%2FB\n这将导致 $2 得到 /example.com/A/B 若依照这个值去proxy_pass显然是错误的\n为了解决这个问题，需要使用if进行正则匹配，这时不会进行decode\n\nDebug的方式\n在http模块中添加error_log logs/debug.log debug;类似的代码即可\nCors Anywhere\n\nNginx指令\nnginx 启动服务器\nnginx -t 检查配置\nnginx -s stop 停止\nnginx -s reload 重载\n","path":null},{"url":"https://yzzfo.github.io/blog/Unity笔记/","title":"Unity笔记","description":null,"body":"遇到的一些问题\n\n某些 Unity 内置错误或者 Exception 不显示 Log\n从 Console window menu 中修改 Stack Trace Logging 中的相关内容即可\n在使用 Build Tool 构建 Android 包的时候出现 Graphic api 不支持相关的报错，发现是 Build 配置中 Texture Comporession 设置为了 Generic 导致的。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Unity包体大小优化/","title":"Unity包体大小优化","description":null,"body":"重复资源\n何时出现重复资源\n在 Unity 中 AB 包和项目本地资源需要当成两个环境来看待，即当 AB 包中引用到了本地资源则每个引用到的 AB 包都会 Copy 一份该资源到自己的包内，例如在 Resouces 文件中存在一个图集 A，以及他的图源 A1，A2，A3，若存在 AB1，AB2 这两个 AB 包分别引用了 A1 和 A2，则资源（图集 A，以及他的图源 A1，A2，A3）将会在 AB1 和 AB2 中都存在一份，这样将导致整个项目中共有（图集 A，以及他的图源 A1，A2，A3）的三个副本。反之一样，若 Resouces 中引用到了 AB 中的资源，则会 Copy 一份到本地。\n解决方法\n解决方法便是对 AB 资源以及本地资源做严格的划分，禁止在制作资源阶段便相互引用。\n如何确认问题，以及查找源头\n在 Unity Build 之后会产生 Editor 日志 (Open Editor Log&nbsp;from the Console window menu)，可以通过日志来确认有什么资源打到了本地之中，在确认到属于 AB 资源相关的路径时，可以在 Editor 下通过类似Maintainer的插件来查找该资源的引用，从而确认问题源头，日志内容类似如下片段。\n\n也可以通过 AssetStudio 来解包，来看看里面具体存在什么资源，从而判断是否出现重复资源。\n对于 AB 资源则可以通过一些插件来进行搜索，对于 Addressable 来说在 2022 版本有 Report 窗口可以看到具体资源打包的情况用于处理重复问题。\n资源导入\n字体\n通常字体文件都比较大，许多人采用字体压缩的方式比如使用 FontZip 来提取出想要的字体来缩减字体大小，然后在 Unity 中使用动态字体，其实在某些场景下也可以使用 Unity 的静态字体，选中字体文件设置 Character 选项为非Dynamic的即可，这么做同样能够减小打包时字体的体积，对于某些场景只需要设置常用的汉字到静态集合中就够了。\n字体在项目中自动引用问题\n有时会发现字体文件自动引用到了项目中另一个字体，即便他们名字并不同，这是因为他们的字体文件中的字体名称是相同的导致相互关联了起来，可以通过修改字体文件来解决，或者直接修改 meta 文件，将关联项删除即可。\n\n参考： https://blog.uwa4d.com/archives/2249.html\n音频和图片\n对于音频主要可以修改一下 Force To Mono，可以将双声道修改为单声道，大幅节省内存，音频和图片主要还是具体看美术效果，在几乎不影响美术效果的情况下可以尽可能的降低质量设置，例如某些地面贴图可以直接改为 32 其效果和 2048 甚至没什么效果上的差异。\n","path":null},{"url":"https://yzzfo.github.io/blog/HybridCLR笔记/","title":"HybridCLR笔记","description":null,"body":"遇到的问题\n\nBuild 时出现 Link 相关的报错，例如 Link Hotfix.dll failed ，可能原因是在非热更程序集中用到了 Hotfix 中的类，例如在 Assembly-CSharp 中使用了 Hotfix 中的类型。\n\nBuildTool\n使用 BuildTool 时出现找不到 ManagedStripped 文件夹或者 miss script 等错误，原因在于 HybridCLR 源码在判断平台时采用的是 宏 进而导致无法在 A 平台下执行 B 平台构建所需要的事情，以及获得相关数据。关于在 Unity 中 miss script 本质的原因是在 Assembly 列表文件中，如 PC 端下的 ScriptingAssemblies.json 文件，而在 HybridCLR 中已经做了补全的操作，只不过因为宏被禁用了而已，所以解决方法很简单，只需要将代码中的宏改为通过 BuildTarget 枚举进行判断即可。例如 PatchScriptingAssemblyList.cs 文件\n\n","path":null},{"url":"https://yzzfo.github.io/blog/修改Editor/","title":"修改Editor","description":null,"body":"   最近在制作技能的时候感觉到 Unity 内建的资源选择工具在选择自建类型的资源时十分的难受，所以尝试来修改一下 Unity 的编辑器。\n整体方案参考 Ultimate Editor Enhancer 这个插件，其修改内建元素时采用的是 Harmony 这个插件，其原理与在雨中冒险mod制作 一文中的 BepInEx 差不多，都是通过 Hook 的方式进行修改。\n修改ObjectField\n入口\nObjectField 的绘制入口是 EditorGUI 下的 DoObjectField 函数，他已经在 ObjectFieldInterceptor 类中被 Hook 了，可以在 Prefix 中劫持点击事件，并打开自己对于的选择界面。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/NodeCanvas/","title":"NodeCanvas","description":null,"body":"   最近弄技能系统的时候又重新拿出了 NodeCanvas，故在这边记录一些 NodeCanvas 相关的东西。\n关于 NC 编辑器代码相关的内容\nAttribute 的绘制逻辑\n以 RequireField 为例，可以发现调用和实际逻辑时通过泛型 AttributeDrawer&lt;RequiredFieldAttribute&gt; 来关联的\n\n\nBBParam\n该类型的 Editor 脚本在 ParadoxNotion\\CanvasCore\\Framework\\Design\\PartialEditor\\Drawers 下，其 object 选择区域也用的时 unity 内置的objectfield\n","path":null},{"url":"https://yzzfo.github.io/blog/UGUI笔记/","title":"UGUI笔记","description":null,"body":"合批操作\n\n\n添加图集\n\n\n设计 Prefab 时尽量保持层级一直，如下图。在该图中通过 SelectEffect 的 active 控制选择特效，这样将会导致该 Prefab 自 SelectEffect 起后续节点的层级将与其他的该 Prefab 实例不一致，从而导致合批失败，正确做法是将 SelectEffect 移到最后一个，这样便可保证前面的元素层级保证一致。\n\n\n\n注意元素大小，如下图。一个 Img 和 Text 不重叠，一个 Img 和 Text 重叠，这也导致层级发生改变，进而导致 Text 无法合批。\n\n\n\n总的来说，在 UGUI 合批时可以依照如下方式判断。\n如果有三个实例化对象，InsA, InsB, InsC，若 Backgroud 和 ContentImg 在同一个图集中，则这六个元素将使用一个 drawcall，对于 Text，若重叠方式都相同，也一个 drawcall，若不同则根据有几种不同的重叠层级确定 drawcall。\n\n\nInsAInsBInsC\nBackgroudBackgroudBackgroud\nContentImgContentImgContentImg\nTextTextText\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Addressable笔记/","title":"Addressable笔记","description":null,"body":"增量更新\n配置\n\n\n修改Addressable Asset Settings中的Catalog，使其支持服务端清单，Only update catalogs manually 选项用于禁止自带的自动更新功能。\n\n\n\n为资源组设置远程模式，其中Use Asset Bundle Cache用于标记该bundle下载后会缓存到设备上，Prevent Updates勾选后则意为该资源为静态资源，对该组的修改后续将进行增量更新，反之为全量更新。\n\n\n\n配置服务器地址，其中RemoteLoadPath对应bundle所在的文件夹，修改Play Mode Script为Use Existing Build用以使用真实环境测试。\n\n\n\n\n打包\n\nBuild第一个包\n\n修改了某个Group中的资源后，进行增量更新，这里只有勾选了Prevent Updates组中的物体才会出现，填入一个新的Group名即增量包名，点击Apply即会创建出一个新的组，之后选择更新新包即可打出新的资源。\n\n\n\n\n代码\n\n测试\n\n在Play Mode Script为Use Existing Build时Editor下也是存在Bundle缓存的，所以也是可以测试更新逻辑的。\n可以通过Unity自带的Web服务来搭建本地文件服务，可以在Play Mode Script为Use Existing Build起作用。\n\n在 Simulate Groups 模式下需要使用如下代码来修改速度，一下设置虽然说是 ProjectConfigData，但没有在 Project 相关配置中找到，只在 Library\\com.unity.addressables\\catalog.json 这个文件中搜索到了相关配置，所以在设置后第一次运行不生效，需要重新生成 catalog.json 才会生效。\n\n\n\n要启用 Event Viewer 需要开启如下选项\n\n\nAddressables.MergeMode\n\nCatalogs\n\n当关闭Only update catalogs manually时Addressables.InitializeAsync();会更新Catalogs文件\n手动调用Addressables.UpdateCatalogs()相当于关闭Only update catalogs manually`干的事\n当勾选Only update catalogs manually时，直接调用Addressables.CheckForCatalogUpdates(false);时Result将包含所有内容。\n更新检查仅是对比Catalogs文件，所以当CheckForCatalogUpdates后去下载对应的文件中途断开后，重新进入CheckForCatalogUpdates将无法获取到新的内容，因为本地Catalogs文件已经为最新的了。\n如果中途断开，若之后用到了被更新的文件，Addressables将去获取新的文件。\n\n\n资源载入\n在Addressable中有两种加载方式，一种是LoadAssetAsync另一种是InstantiateAsync，他们的区别在于，LoadAssetAsync后必须Release否则引用计数会一直存在，InstantiateAsync则是当切换场景时，若实例化的对象被销毁了对应的引用计数也会消失。\n在Addressable类这个层，LoadAssetAsync和InstantiateAsync均可以使用Release进行销毁，ReleaseInstance仅添加了实例判空检测。\n之所以InstantiateAsync在切换场景是会判断引用计数是可以参考Library/PackageCache/com.unity.addressables@1.21.9/Runtime/ResourceManager/ResourceProviders/InstanceProvider.cs可以看到对于实例化物体都有一个字典将其记录了。\nRelease注意点\n\n注意点\n\nNon-Recursive Dependency Calculation：开启该选项可以提高构建速度同时减少运行内存的占用，但资源存在循环依赖时会导致加载失败。不建议开启。\n场景切换时死锁问题\n切换平台后, Editor 下读取路径出现问题，解决方法是清除一下缓存。\n切换 Android 后出现 TLS 错误，在开发模式下 Edit -&gt; Project Settings -&gt; Player -&gt; Other Settings -&gt; Configuration -&gt; Allow downloads over HTTP 可以在这设置一下。\n读取 Built in date 中的文件时文件Key 没有后置名，同 Resource. Load 一样不需要文件后缀名，截至 1.21 版本在 Group 界面下复制 Resources 文件夹下的 Key 时还是会多出后缀名，去除后缀名才是真正的 Key。具体参考 ResourceLocationMap.cs 文件中的 Locate 函数，在此处断点可看到具体的 Key 值。\n\n缓存位置\n项目名 : com.DefaultCompany.Addressables\nPC/Editor :  C:\\Users\\\\AppData\\LocalLow\\Unity\\DefaultCompany_Addressables\n安卓 :InternalSharedStorage&gt;Android&gt;data&gt;com.DefaultCompany.Addressables&gt;cache&gt;vulkan_pso_cache.bin\n关联文章\n\n场景相关内容\n\n参考资料\n\nAddressables之使用 截图存档\nhttps://zhuanlan.zhihu.com/p/243606717\nhttps://www.jianshu.com/p/dfa98f540673\nhttps://medium.com/swlh/need-a-local-static-server-here-are-several-options-bbbe77e59a11\nhttps://www.bilibili.com/read/cv11642315\nhttps://answer.uwa4d.com/question/62a18c85b87a457351737513\nhttps://www.cnblogs.com/qq2351194611/p/16601170.html\nhttps://docs.unity3d.com/Packages/com.unity.addressables@1.20/manual/SynchronousAddressables.html\n\n","path":null},{"url":"https://yzzfo.github.io/blog/使用Addressables加载场景/","title":"使用Addressables加载场景","description":null,"body":"在Unity中可以通过如下方式加载场景\n\n但这两种方式均存在问题，如下\n\n异步加同步加载时Update报错\n\n\n\n\n场景的Active存在延迟\n\n\n\n对于这两个问题其实都是由于Unity资源加载异步实现方式导致的，在Unity中资源加载完成后的回调是通过在Update中轮询完成的，即资源即便已经加载好了，这个时间也需要到下一次的Update中去派发事件。\n所以可以采用UniTask中的await UniTask.Yield(PlayerLoopTiming.LastUpdate);在资源加载结束后使用该函数将任务移到Update的结尾处，这样便能确保ActivateAsync已经结束了，而且也可以跳出Update的报错。\n\n显示进度\n\n注意点\n场景切换卡死\n\n切换场景时场景中存在同步加载的资源时导致卡死，原因如下\n\n\n\n虽然文档说是因为 Scene 切换时不能同步是因为切换时会 UnloadUnusedAssets，但经过实验发现调用 Resources.UnloadUnusedAssets() 后立马去同步 Load 资源也不会卡死，应该是 Scene 切换时还有其他的操作导致 Lock 住了其他的资源加载。可以参考 Addressables AssetLoading is blocked by Async Scene Loading\n卡死问题复现的代码\n\n\n\n解决方式是，若要使用同步加载需要预加载资源\n\n\n\n还遇到过在切换场景后的 1-2 帧内 LoadAsync 某个特定资源是 Editor 卡死且 CPU 占用率为 0，且无法断点定位。\n后发现可以等待几帧在去加载资源。\n通过在 Groups 面板中删除资源，重新拖回去之后重新 Build 资源彻底解决了部分该问题，但至于为什么出现这个情况未知。\n最终解决方方法还是需要等到场景彻底加载完之后再去请求资源加载才不会卡死，即 await ret.ActivateAsync(); 和同步加载时的策略一样。\n\nUnity中的时序\n\n参考资料\nUnity 2018 and PlayerLoop\nAddressables之使用\n","path":null},{"url":"https://yzzfo.github.io/blog/Tilemap/","title":"Tilemap","description":null,"body":"Isometric\n设置渲染轴\n\n在SRP下Edit &gt; Project Settings &gt; Graphics 设置Transparency Sort Axis 为 (0, 1, 0)\n\n在URP下需要进行如下设置\nCreate &gt; Rendering &gt; URP Asset (with 2D Renderer)创建2D渲染器\n在Project Settings &gt; Graphics中使用2D的渲染管线\n查看相机Rendering &gt; Renderer属性中是否选择到了目标文件，若没有则到Project Settings &gt; Quality中查看当前是否有旧的Render Pipeline Asset设置残留，比如用URP 3D 模板创建的项目会更预先生成几份不同画质的配置在此处设置，会导致第二步中的配置被该处覆盖，可根据项目质量自行在该出修改。\n在Renderer2D文件中修改轴\n\n设置图片资源以及网格比例\n\n如上图所示，在Isometric中，一个物体本质是由一个基础的面从上自下刷出来的，计算比例时便是拿这个基础的面，在这个图片中其比例为(128 : 66) =&gt; (1 : 0.515)\n设置CellSize\n在Grid组件上，Size采用Unity空间下的长度为单位，若要将上图的映射到一个格子内，则Size需要满足比例(1 : 0.515)才能保证平铺，此处以(2 : 1.03)为例子\n设置图片所对应的Unit大小\n为了铺满(2 : 1.03)则Pixels Per Unit设置为128/2=64，使得在该图片中每128px对应Unity空间中的长度2即可。\n关于Pattern\nPattern只不过是一个预制体+Editor，当创建完后想修改基本参数如Cell Layout则可以到预制体中修改，Pattern中设置并不会影响到实际场景中，显示仅作为在该种布局下的预览而已，例如在Pattern中设置Layout为Rectangle但是场景中是Isometric也并不影响。\n一些笔记\n计算坐标\n\n","path":null},{"url":"https://yzzfo.github.io/blog/UI-ToolKit/","title":"UI ToolKit","description":null,"body":"  Unity在2019之后就可以使用UI ToolKit来制作，其制作理念和web前端基本一致，所有这里记录一下相关的内容。\n基本结构\n通过Create &gt; UI Toolkit &gt; Editor Window即可创建一个最基本的Editor窗口\n\n监听UI事件\n\nListView\n\n拖拽相关内容\n修改鼠标样式\n  在反编译查看了下ObjectField后发现了DragAndDrop.visualMode = DragAndDropVisualMode.Generic这一行代码，试了一下后发现可以用于修改拖拽时的鼠标样式\n\n获取拖拽的物品\n  可以通过DragAndDrop或者Selection下的属性来获取相关内容\n\n修改Sprite\n修改资源时需要修改对应的Importer，AssetImporter.GetAtPath，有些修改项不在import中需要使用对应的ImporterSettings，如下面例子。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/平面反射/","title":"平面反射","description":null,"body":"\n反射矩阵推导\n\n\n用向量表示平面\n由上面的推到可以发现NP-D=0为平面推广到向量则是\n\n法线变换\n\n法线，平面等变换的证明\n参考: https://zhuanlan.zhihu.com/p/396873139\n\n斜投影\n在Unity中直接通过如下形式计算\n\n具体原理参考\n\n反射矩阵与斜投影\nLengyel-Oblique\n\n\n\n参考资料\n法线变换、逆转置、伴随转置\n","path":null},{"url":"https://yzzfo.github.io/blog/Unity-Mesh/","title":"Unity Mesh","description":null,"body":"SharedMesh和Mesh的区别\nsharedMesh是指MeshFilter组件中共享的mesh，它会影响所有使用这个mesh的对象。如果你想修改一个对象的mesh而不影响其他对象，你可以使用MeshFilter组件中的mesh属性，它会返回一个新的mesh副本。\nSubmesh和Materials\nSubmesh 是指一个 mesh 中的一部分，可以用来给不同的部分应用不同的材质。对应到 Blender 中则是一个 object 中存在多个分开的网格，如下图 mesh 中存在两个 submesh(材质不同的时候两个，相同的话一个)。\n\nSubmesh和Materials对应的关系为\n\n若Submesh数量等于Material数量，则index对应赋值\n若Submesh小于Material数量，相等部分对应赋值，多出的Materials重复作用于最后的Submesh上\n若Submesh大于Material，相等部分对应赋值，剩下的Submesh都使用最后的一个Material\n\nCombineMesh\nCombineMesh有一个参数叫mergeSubMeshes，它可以控制合并后的mesh是否只有一个submesh。如果你设置为true，所有的submesh都会合并成一个submesh。如果你设置为false，每个submesh都会保留在不同的submesh中即需要一个drawcall。\n\nCombineMesh的好处\n当mergeSubMeshes为false的时候，可以看出来他的drawcall并没有降低，对于类似换装系统这样的功能来说倒是可以将多个SkinmeshRender变成一个SkinmeshRender，可能从结果上来看可以减少一些渲染状态切换之类的东西，例如每次渲染Unity都需要设置一些渲染参数，比如材质、光照、混合模式等。如果你把多个mesh合并成一个mesh，你就可以减少这些参数的设置次数，从而提高效率。\n\nTriangle\n在存储顶点以及确定它们的三角面时通常会有如下几种方法:\n\n\n三角形条带法：这是一种绘制三维图形的方法，它可以减少顶点数据的冗余，提高渲染效率。它的原理是，按照一定的顺序指定一系列顶点，然后每相邻的三个顶点构成一个三角形。例如，如果指定了7个顶点v1,v2,v3,v4,v5,v6,v7，则会绘制出4个三角形：v1v2v3, v2v3v4, v3v4v5, v4v5v6。\n\n\n三角形扇法：这也是一种绘制三维图形的方法，它可以用较少的顶点数据来表示圆锥或球体等曲面。它的原理是，以一个顶点为中心，与其他顶点依次构成一系列扇形的三角形。例如，如果指定了6个顶点v1,v2,v3,v4,v5,v6，则会绘制出5个三角形：v1v2v3, v1v3v4, v1v4v5, v1v5v6, v1v6v2。\n\n\n四边形条带法：这是一种绘制四边形网格的方法，它可以用两条线把一系列四边形交错起来。它的原理是，按照一定的顺序指定一系列顶点，然后每相邻的四个顶点构成一个四边形。例如，如果指定了8个顶点 v1,v2,v3,v4,v5,v6,v7,v8，则会绘制出3个四边形：\n\n\nv1-v2-v4-v3\n\n\nv3-v4-v6-v5\n\n\nv5-v6-v8-v7\n\n\n索引缓冲法：这是一种优化渲染性能和内存使用的方法，它可以避免重复存储相同的顶点数据。它的原理是，使用一个数组来存储所有不重复的顶点数据（称为顶点缓冲），然后使用另一个数组来存储每个图元（如三角形或四边形）所需的顶点索引（称为索引缓冲）。例如，如果要绘制一个立方体，则只需要8个不同的顶点和36个索引。\n\n\n在Unity在Meshfileter的triangles属性就是使用的索引缓冲法。对于不同的存储方法，在OpenGL中也是有对应不同的绘制方法，有些图元类型是每三个点认为一个三角的索引缓冲法，比如GL_TRIANGLES，有些图元类型是用的三角形条带法，比如GL_TRIANGLE_STRIP。\n三角形条带法的一些劣势\n人物的网格通常是非常复杂和不规则的，很难用一系列连接的三角形来表示。如果要用三角形条带法来绘制人物，就需要分割成很多小的条带，并且使用很多退化的三角形来连接它们，这样就会降低效率和质量。\n三角形条带法有可能无法画特点拓扑的模型，它只能用一系列连接的三角形来表示网格，而不能自由地指定任意顶点之间的连接关系。\n这样就会导致一些问题，例如：\n\n三角形条带法不能绘制具有洞或凹陷的模型，因为这些模型需要断开或跳过一些顶点。\n三角形条带法不能绘制具有复杂曲面或细节的模型，因为这些模型需要更多或更少的顶点来控制曲率或密度。\n\n如果模型需要在某些地方有很高的法曲率，就需要增加顶点来使三角形条带能够适应这种弯曲变化。\n如果模型需要在某些地方有很低的法曲率，就需要减少顶点来使三角形条带能够保持平滑和均匀。\n但是三角形条带法只能用顺序的顶点来表示网格，不能根据不同位置和方向调整顶点数量和位置。\n\n\n三角形条带法不能绘制具有动画或变形的模型，因为这些模型需要更好的拓扑结构来保持平滑和连贯。\n三角形条带法的定义是：一系列连接的三角形，其中每个新顶点与前两个顶点共享一条边。三角形条带法的实现是：使用一个数组或缓冲区来存储顶点数据，然后按照固定的规则来遍历这些顶点并绘制三角形。因此，如果要改变顶点数量或位置，就需要重新创建或修改数组或缓冲区，并重新遍历和绘制所有顶点和三角形。这样就会增加计算和内存开销，并降低渲染效率。\n\n索引缓冲法则可以更灵活地指定任意顶点之间的连接关系，从而可以绘制任何形状的网格，包括人物。\n","path":null},{"url":"https://yzzfo.github.io/blog/Unity-Shader-Depth/","title":"Unity Shader Depth","description":null,"body":"在之前学习Shader时一直有一个误解，认为SV_POSITION在Frag阶段依旧是裁剪坐标系，于是在手动计算深度缓存时出现了一些问题，原因在此。\n通常来说在NDC空间下z值(-1,1)映射到depth = 0.5*ndcz+0.5，即ZBuffer中的值。在Frag阶段只需通过SV_POSITION即可获取当前像素所在的depth值。\n\n\n也可以通过Unity提供的API在Vertex阶段来计算深度\nUnityCG.cginc\n\n\n在顶点阶段调用上面的任意函数获取深度值，之后到片元着色器去使用，在片元着色器通过如下函数对_CameraDepthTexture中的值解码\n\n使用案例\nVertex\n通过顶点计算深度值\n\nFrag\n获取当前ZBuffer中的值的方式\n_CameraDepthTexture\n\n\n\n这样，相机就会生成深度纹理，并且你可以在Shader中访问它。如果是延迟渲染，则不需要手动设置，因为相机默认就会生成深度纹理。\n\n\n\nNote\n_CameraDepthTexture生成的Depth是通过\"LightMode\" = \"ShadowCaster\"的Pass来渲染出来的，在Surface Shader中通常只需要加入addshadow即可，若Shader中两者都不存在，若Fallback中的Shader有ShadowCaster也会渲染出Depth。\n\n也存在一种不需要任何设置就能获取的全局属性_LastCameraDepthTexture即上一次的深度信息，使用方式同上。\n\n_CameraDepthNormalsTexture\n\n\n\n\n\n\n通过该模式，你可以在Shader中访问到Depth以及Normal信息\n\n\n\nNote\n_CameraDepthNormalsTexture使用的ShaderReplacement进行生成，ShaderReplacement通过匹配RenderType进行替换操作，默认使用Internal-DepthNormalsTexture.shader进行替换操作，若要更改需要在Unity中进行相关设置，如下图。\n\n\n\n一些疑问\n\n在Unity中为什么NDC空间下Z值越近越大？\n在Unity中，NDC空间下的z值从大到小是因为Unity使用了反向z(Reversed-Z)来处理z fighting问题。反向z先是把摄像机的矩阵改了，然后自动把你的shader的ztest creater和ztest less翻转，深度测试本身就没问题了。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Shader-Pass/","title":"Shader Pass","description":null,"body":"Tag是一种用来给SubShader或Pass添加一些额外信息的语法，可以影响渲染的顺序、方式和效果。\nUnity Shader里的Tag分为两种，一种是子着色器（SubShader）Tags，一种是通道（Pass）Tags。\n子着色器Tags可以设置以下几种：\n\nQueue：表示渲染队列，决定了物体的渲染顺序。\nRenderType：表示渲染类型，用于后处理效果和替换渲染等功能。\nDisableBatching：表示是否禁用批处理，用于优化性能。\nForceNoShadowCasting：表示是否强制不产生阴影，用于优化性能。\nIgnoreProjector：表示是否忽略投影器的影响，用于优化性能。\nCanUseSpriteAtlas：表示是否可以使用精灵图集，用于优化性能。\n\n通道Tags可以设置以下几种：\n\nLightMode：表示光照模式，决定了这个pass在何种光照下被激活。\nName：表示pass的名字，用于调试和识别。\nRequireOptions：表示需要满足的条件才能激活这个pass，例如需要开启雾效或者HDR等。\n\nSubshader中拥有多个相同的RenderType时\n\n如果你的一个shader中有好几个相同rendertype的subshader，那么只有第一个能够运行在用户的显卡上的subshader会被渲染，其他的subshader会被忽略。\nUnity会根据用户的显卡性能和设置来选择最合适的subshader，所以不同的subshader应该提供不同的渲染效果和质量。\n如果你想要在一个shader中实现多种渲染类型，你可以使用多个pass来实现，而不是多个subshader。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Shadow/","title":"Shadow","description":null,"body":"Unity的shader实现阴影的方法有多种，其中一种是使用Shadow Map技术。Shadow Map是一种记录光源视角下场景深度信息的纹理，可以用来判断物体是否在阴影区域。\n\n如果想要渲染的物体接收阴影，就要在Shader中对阴影映射纹理进行采样，通过采样结果和光照结果相乘来产生阴影效果。Unity提供了一些内置的宏和函数来方便这个过程，例如SHADOW_COORDS, TRANSFER_SHADOW, SHADOW_ATTENUATION等。\n如果想要渲染的物体产生阴影，就要在Shader中添加一个ShadowCaster Pass，用来告诉Unity如何生成Shadow Map。Unity也提供了一些内置的宏和函数来简化这个过程，例如SHADOW_CASTER_FRAGMENT等。\n在普通Shader中实现接收Shadow\n\n相关宏的定义\n\nTRANSFER_SHADOW\n将顶点坐标转换到阴影视锥的空间中\nSHADOW_ATTENUATION\n采样\n阴影投射\n在普通Shader中实现阴影投射\n\n在Surface Shader中实现\n在默认的模板情况下，我们直接使用alphatest剔除像素后，该物体所投射的阴影依旧是完整的，这时需要在optionalparams加入addshadow指令\n除了Shadow Map之外，还有其他的实现阴影的方法，例如Screen Space Shadow Map、Shadow Matte Shader、Unlit Shader with Shadow Caster Pass等。\n","path":null},{"url":"https://yzzfo.github.io/blog/Surface-Shader/","title":"Surface Shader","description":null,"body":"  Surface Shader是Unity进行抽象过的一层Shader，有时候想基于Unity默认Shader的基础上加一些特效时使用Suface Shader在合适不过了，创建默认的Surf Shader时便以及实现了PBR相关的功能。\n使用方法\n编译指令\n# pragma surface surfaceFunction lightModel [optionalparams]\n类似透明度测试之类的东西需要在optionalparams处声明\nInput\n只能使用Unity提供的相关变量，诸如worldPos，screenPos等\n顶点动画\n在optionalparams中加入vertex:VertexFunction，并编写对应函数即可\n\n阴影\n在默认的模板情况下，我们直接使用alphatest剔除像素后，该物体所投射的阴影依旧是完整的，这时需要在optionalparams加入addshadow指令\n一个Dissovle的例子\n\n参考资料\n编写表面着色器 - Unity 手册 (unity3d.com)\nSurface Shader examples\n","path":null},{"url":"https://yzzfo.github.io/blog/Shader中的分支/","title":"Shader中的分支","description":null,"body":"  在学习Shader时经常会看到这么一条注意事项少用if else语句，通常的原因是在着色器中使用条件语句（如if）可能会影响效率，因为它们会破坏着色器的并行性。如果你想根据某个值的大小来选择不同的输出，你可以使用step函数，它会返回0或1，然后你可以用它来做插值或混合。step函数比if语句更高效，因为它没有分支。\n为什么Step比 If 快\nstep函数的实现可能会根据不同的平台和语言有所差异，但是一种常见的实现方法是使用比较运算符和逻辑运算符。例如，如果你想实现一个返回0或1的step函数，你可以这样写：\n\n这里的?是一个三元运算符，它相当于一个简单的if-else语句，但是它不会产生分支。你可以把它理解为：\n\n但是这种写法就会有分支，因为它会根据条件选择不同的返回值。而三元运算符只是一个表达式，它会同时计算两个可能的返回值，然后根据条件选择其中一个作为结果。这样就避免了分支。\n三目运算符为什么没有分支，这个问题的答案可能会取决于编译器和CPU的具体实现。一种可能的解释是，三目运算符是一个表达式，它可以被优化为一个单一的指令，而不需要跳转或分支。另一种可能的解释是，三目运算符可以让CPU更容易预测条件的结果，从而减少分支预测错误的代价。无论哪种情况，三目运算符都比if语句更高效，因为它避免了不必要的分支。\n一些写法\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Shader-Semantics/","title":"Shader Semantics","description":null,"body":"  在学习Shader是经常会看到诸如TEXCOORD0,POSITION,这样的东西，这些东西叫做Semantics中文叫做语义。\n作用\n在Unity的shader中，TEXCOORD0，POSITION等都是用来表示顶点和片元的数据的语义。语义是用来指示HLSL shader程序中输入和输出变量的意图的。\n例如，POSITION语义表示顶点在裁剪空间中的位置，以便GPU知道屏幕上的光栅化位置和深度。&nbsp;TEXCOORD0，TEXCOORD1等语义用于表示任意高精度数据，如纹理坐标和位置。&nbsp;顶点输出和片元输入的COLOR0和COLOR1语义用于表示低精度0到1范围的数据（如简单的颜色值）。\n语义的规则或限制\n\n语义必须是从以下列表中选择的：POSITION，NORMAL，TANGENT，TEXCOORD0-7，COLOR0-1，SV_Target等。\n语义必须与变量的类型和维度匹配。例如，POSITION必须是float3或float4，COLOR0必须是float[2|3|4]等。\n语义不能重复使用。例如，不能有两个变量都使用TEXCOORD0语义。\n片元shader的输出语义通常是SV_Target，表示输出的颜色值。\n\n可以参考MSDN上的Semantics文档来了解更多细节。\n为什么要使用语义\n使用这些语义的原因是，它们可以传递关于参数的预期用途的信息，从而使shader程序与GPU和其他shader阶段之间的通信更加清晰和有效。\n例如，POSITION语义告诉GPU这个变量是用来表示顶点位置的，而TEXCOORD0语义告诉GPU这个变量是用来表示纹理坐标的。这样，GPU就可以根据语义来正确地处理和插值数据，并将其传递给下一个shader阶段（如片元shader）。\n可以把语义看作是一种约定或标签，它们帮助组织和管理shader代码，并避免一些错误或混乱。\n系统语义\n为什么MSDN上TEXCOORD0为float4，使用时却可以声明为float2，但在规则或限制中却说了类型必须匹配？\n\n之前说的POSITION必须是float3或float4类型，是指在顶点shader输出或片元shader输入时，使用的SV_POSITION语义，这个语义是用来表示顶点在裁剪空间或屏幕空间的位置的，它是GPU栅格化和深度测试所必需的\n由于裁剪空间和屏幕空间都是三维或四维的，所以SV_POSITION语义必须使用float3或float4类型来声明。&nbsp;如果使用其他类型，例如float2，那么GPU将无法正确地计算顶点的位置和深度，从而导致渲染错误。\nCOLOR也同理，指的shader片元输出时的SV_Target语义。\n根据MSDN中所述DX10的SV_Target等效DX9的COLOR,所以在Unity中会看到一些宏定义将SV_Target定为COLOR\n而TEXCOORD0语义则不同，它只是用来表示纹理坐标或其他任意数据的，并不影响GPU栅格化和深度测试。&nbsp;因此，TEXCOORD0语义可以使用任何合适的类型来声明，只要与其他shader阶段之间的数据传递保持一致即可。\n他们之间的差别就在于SV_POSITION语义是一个特殊的系统值语义（System-Value Semantics），它有一些固定的规则和约束，而TEXCOORD0语义则是一个普通的用户定义语义（User-Defined Semantics），它有更多的灵活性和自由度。\n\nNote\nSV_POSITION\n以SV_POSITION为例，他在Vertex和Frag阶段时所代表的数据是不同的\n\n参考\n\nglsl - 为什么HLSL有语义？- 堆栈溢出 (stackoverflow.com)\nSV_POSITION 在Pixel Shader中的使用 - 知乎 (zhihu.com)\n\n","path":null},{"url":"https://yzzfo.github.io/blog/QuardTree/","title":"QuardTree","description":null,"body":"  四叉树经常被用于空间管理，例如在进行碰撞检测时，可以利用四叉树排除不和能碰撞的对象从而优化碰撞检测算法。\n为什么要用四叉树\n\n虽然Unity默认开启视锥体剔除，视锥体剔除是在应用阶段通过视锥体与模型的AABB包围盒的八个顶点来判断该模型是否被剔除。但是，如果场景中的物体过多时，每次渲染前都要进行很多次判断，时间复杂度为O(n)，所以需要四叉树来划分区域，将某一部分区域的物体划分到一个包围盒中，从而来减少判断次数，提高效率\n\n为什么Unity视锥剔除没用四叉树\n\n四叉树需要额外的内存和预处理时间来构建和维护，而Unity的视锥体剔除是基于物体的AABB包围盒和摄像机的视锥体来判断的，这样可以节省内存和时间。\n四叉树可能不适合处理动态物体或者非均匀分布的物体，而Unity的场景中可能包含各种类型和大小的物体。\n四叉树可能对阴影渲染没有优化效果，因为阴影渲染时需要考虑光源的位置和方向，而不仅仅是摄像机的视锥体。\n\n松散四叉树\n松散四叉树的特点是，每个节点的出口边界比入口边界要稍微宽些，这样可以减少物体在不同节点之间切换的次数，它相比于普通的四叉树，更适合处理动态物体。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/在N6005中使用AVX指令/","title":"在N6005中使用AVX指令","description":null,"body":"  自从mongodb5.x开始就要求CPU必须支持AVX指令集了，但现在大多数小主机CPU以N5105或者N6005居多，都不支持AVX，于是就得通过模拟的方式来支持AVX了。所幸从Qemu7.2开始支持模拟AVX指令了，而在最近的PVE7.4中也默认开始使用Qemu7.2了，所以打算试一试模拟的效果，Qemu相关的操作可以参考[[Qemu笔记]]\n环境\nCPU: N6005\nOS: PVE7.4\n配置CPU\n查看使用手册man cpu-models.conf\n在/etc/pve/virtual-guest/cpu-models.conf文件中输入如下内容\n\n保存后即可在WebUI中的CPU选项卡中看到custom-avx选项，选择custom-avx并保存\n关闭KVM hardware virtualization\n在系统的Option选择卡中选择KVM hardware virtualization并关闭\nElse\n上面两步也可以通过直接编辑qm-conf来实现。\n检查\n开机后输入cat /proc/cpuinfo | grep avx来查看是否成功激活了avx指令\n","path":null},{"url":"https://yzzfo.github.io/blog/Qemu笔记/","title":"Qemu笔记","description":null,"body":"创建磁盘\nqemu-img create -f qcow2 alpine.qcow2 8G\n安装系统\nqemu-system-x86_64 -m 512 -nic user -boot d -cdrom alpine-standard-3.17.2-x86_64.iso -hda alpine.qcow2 -vnc :0 -cpu kvm64,+avx -enable-kvm\n从磁盘启动\nqemu-system-x86_64 -m 512 -nic user -hda alpine.qcow2\nVNC\n加入 -vnc :0 即0.0.0.0:5900,使用VNC Viewer连接即可\n启用KVM虚拟化\n-enable-kvm，kvm可以直接让虚拟系统使用宿主机cpu的指令集，如果cpu支持的话开启后拥有较高的性能。若想用不支持的指令则不应该加入该选项，例如N6005不支持avx，所以要使用avx时则不能填入该选项。\n直接在终端中与Qemu中的系统交互\n-nographic 即可直接在运行qemu命令的终端中操作虚拟系统\n配置CPU\n-cpu kvm6,+avx 配置cpu，kvm6为模板包含一些基础的指令，+avx为添加avx指令\n-cpu help获得更多信息\n参考资料\n\n“Emulation”和“Hardware virtualization”的比较\nHow to Setup QEMU Output to Console and Automate Using Shell Script\nqemu-manpage\n\n","path":null},{"url":"https://yzzfo.github.io/blog/FEC/","title":"FEC","description":null,"body":"  在游戏开发时人们经常会实现一些网络传输方案，在使用tcp时，由于其的确认机制及拥塞控制通常会导致网络波动，而udp则过于简单仅包含一份数据传输时所需的基本信息，这也使得udp可以快速传递信息。对于游戏而言我们希望的传输协议应该具有一下几点:\n\n低延迟\n尽可能的可靠\n有序\n\n为了实现这一点通常就是使用udp来实现一个简易的tcp，剔除tcp中一些繁杂的检测机制，在传递信息时我们允许一些丢包而不是在那一直等待，例如在同步玩家位置这类并非十分关键的数据时，中间丢失几帧的信息是可以允许的。\ntcp在传递数据时采用的滑动窗口来保证数据的可靠及有序，在出现丢包时会触发重传机制，这也就导致了延迟的增大，这时就需要使用FEC技术。\nFEC即Forward Error Correction的缩写，中文为前向纠错，FEC是利用数据进行传输冗长信息的方法,当传输中出现错误,将允许接收方修复数据。\nXOR FEC\n在二进制情况下异或操作有如下特性,其实本质就是不进位加法\n\n1为取反\n0保持不变\n0^1^0^1^1^X 当1的总数为奇数时结果为1偶数为0\n\n所以当我们有N组数据时，通过将N组数据进行异或操作，即可获得一份纠错数据，例如:\n\n该方法的好处在于当只丢失任意一份数据时，我们都能找回来，即增加1/N的冗余数据即可保护剩下的N份数据。\nReed-Solomon Codes\n当希望在丢失更多份数据时也能恢复出原本的数据时就需要使用里德-所罗门码，具体细节参考\n\nhttps://www.geeksforgeeks.org/what-is-reed-solomon-code/\nhttps://zhuanlan.zhihu.com/p/104579290\n\n","path":null},{"url":"https://yzzfo.github.io/blog/AI绘画/","title":"AI绘画","description":null,"body":"  最近看着AI绘画挺有趣的加之新配了一台电脑于是就打算来尝试一下AI绘画。\n使用工具\n\nStable Diffusion web UI 主要的工具，可用于生成图片以及训练模型\nKohya's GUI 主要用于训练lora等模型\n\n安装注意事项\n翻墙时\n在Windos下使用clash翻墙安装时需要在对应bat文件中输入SET HTTPS_PROXY=http://ip:port，直接在powershell输入时不知为何不生效。\n不翻墙时\n可以采用更改源的方式进行安装\n\n参考\n\ngit使用代理加速github下载\n如何修改 Python 中的 pip 安装源\n\n相关概念\nPrompt 提示词，用于形容图片的词汇\nCheckPoint 基础模型，泛化性好\nTextual Inversion/Embedding 主要用于训练人物特征\nHypernetwork 主要用于训练画风\nLora 主要用于训练人物特征，效果比Textual Inversion/Embedding好\nDreambooth 主要用于处理输出，可以固定某样东西的出现\n资源网站\nCivitai 大量模型分享的网站，且可以看到\nThe AI community  大量AI相关的东西\nBirme 图片裁剪网站\n使用方法\n调参\n参考：https://www.bilibili.com/read/cv19126281\nEmbedding &amp; Hypernetwork使用及训练\n参考： https://www.bilibili.com/read/cv20183008\nLoRA训练\n \nDreambooth训练\n \n","path":null},{"url":"https://yzzfo.github.io/blog/同屏渲染大量单位的一些方案/","title":"同屏渲染大量单位的一些方案","description":null,"body":"  最近遇到需要同屏渲染几百个单位的需求，在Unity中SkinnedMeshRender默认也没有合批这一说，首先就得解决一下这几百个Batch的问题。\nNVIDIA 在 GDC 曾提出，25K batchs/sec 会吃满 1GHz 的 CPU，100%的使用率。\n即有如下的估算公式\n\nAnimation-Instance\nAnimation-Instance是Unity官方的一个插件，在对SkinnedMeshRender进行合批的同时也提供了其他常用的API，接入项目时比较方便。\nAnimMap Baker\nAnimMap Baker相较与Animation-Instance做法更加激进，直接将动画烘焙进了图片之中，所有动画均用顶点动画实现，压力全放于GPU上了，且API提供的较少接入项目较为麻烦。\n参考\n\nhttps://github.com/chenjd/Render-Crowd-Of-Animated-Characters\nhttps://github.com/Unity-Technologies/Animation-Instancing\nhttps://zhuanlan.zhihu.com/p/364918045\n\n","path":null},{"url":"https://yzzfo.github.io/blog/UGUI图集笔记/","title":"UGUI图集加载问题","description":null,"body":"  之前开发UI时都使用的NGUI或FairyGUI，最近在使用UGUI时发现打完包后图集资源始终无法加载出来，在一番调试之后找到了问题所在，所以来记录一下。\nUGUI图集与NGUI的不同之处\nNGUI\n制作\nNGUI打图集时需要用户指定所需的图片之后由程序生成一张大图作为图集\n使用\nNGUI使用图片时需要先传入图集之后选择里面的图片\nUGUI\n制作\nUGUI制作图集时需要先创建Sprites Atlas文件，之后将需要的图片拖入其中即可，同一个Sprite 可以存在于多个图集之中\n使用\n直接将Sprite载入组件中即可\n问题所在\n从制作方式和使用方式中可以看出来，NGUI中资源是强关联的关系，在资源打包时是可以知道该预制体依赖哪个图集，UGUI中依赖Sprite，但Sprite是被图集依赖的对象，且可以存在于多个图集之中，这时就不能通过依赖分析的方式正确的加载图集文件了。\n解决方法\n指定依赖\n在UI基类中指定一个字段填写所依赖的图集资源，在加载资源时同步加载所需图集。\n使用SpriteAtlasManager\n当一个Sprite打包进了图集但在运行期间无法找到该图集时触发，如果Sprite在多个图集中则随机选一个图集，该方法的坏处在于异步加载时会导致图片空几帧。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/搭建CloneBot_V2/","title":"搭建CloneBot_V2","description":null,"body":"CloneBot V2是一个Telegram的机器人，用于转存Google Driver的资源\n安装方式\n获取共享盘\nhttps://t.me/MSGuite_SD_Creator_Bot\n配置文件\n\n将配置文件存到GitHub Gist中\nDocker-Compose\n\n创建Service Accounts，让机器人正常运行\n方式一\n\n参照 https://alist-doc.nn.ci/docs/driver/googledrive/#%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91%E7%89%88%E5%9C%A8%E4%B8%8B%E9%9D%A2 文章创建API和OAuth\n在选项API和服务-&gt;凭据-&gt;服务账号中添加一个新的账号，添加后点击操作-&gt;管理密钥对密钥进行设置在结束时选择保存为json。\n参照该文章设置Google Group https://github.com/TheCaduceus/CloneBot_V2#-adding-in-google-group ,用于赋予操作网盘的权限\n上面获取的json就是一个用于操作的sa账户\n将其打包到accounts.zip，发送至机器人并附带/sa即添加成功了账号\n\n方式二\n参考这篇官方文章 https://github.com/TheCaduceus/CloneBot_V2#-service-accounts  ,我在按照里面的操作进行是出现机器人读不到共享磁盘的问题，可能是由于当时操作出现网络问题，故没有继续尝试下去，后改为方式一操作成功。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Rclone的用法/","title":"Rclone的用法","description":null,"body":"在Docker-Compose中挂载Rclone\n\n关于挂载缓存相关的选项\n\n进入容器进行配置\n\n重新启动容器\n\n若出现类似ls: cannot access './rclone/mnt/alist': Transport endpoint is not connected这样的问题，需要先fusermount -u /mnt/alist\n缓存持久化\nrclone的缓存在~/.cache下，缓存持久化有助于重启rclone后继续上传未完成的任务\n配置类似 - ./rclone-alist/cache:/root/.cache 这样的路径映射即可，若存在大量未完成的上传任务，此时重启rclone并不会立即挂载上去，需要等待一定的时间才会挂载成功\n占位\n若要在docker中使用rclone挂载的目录，但又不希望在目录还未成功挂载的时候被写入，可以在还未挂载的时候使用类似如下的指令mkdir /mount/point &amp;&amp; chmod 000 /mount/point &amp;&amp; chattr -i /mount/point这样将创建一个文件夹，该文件夹无法写入以防止程序误写入本地磁盘中，直到rclone挂载成功后会将其顶替\n使用Rclone架设webdav\nrclone serve webdav\n\n使用Nginx反代时IO过高的问题\n需要设置proxy_buffering off;\n可参考nginx存在大量磁盘io问题及解决方案\n配置Google Driver\n可以参考此教程Rclone怎么挂载？Rclone挂载谷歌团队共享云盘远程同步\n上面教程中的rclone authorize \"gdrive\" \"Client_ID\" \"Client_secret\"在新版本中是错误的，gdrive改名为了drive，后续使用该命令时需要用rclone help backends需要确认一下名称。\n","path":null},{"url":"https://yzzfo.github.io/blog/在Docker中禁止容器使用Swap/","title":"在Docker中禁止容器使用Swap","description":null,"body":"环境\nUbuntu22.04\nDocker 20.10.21\n启用CGroup中的Swap控制功能\n\n在/etc/default/grub文件中编辑或者加入GRUB_CMDLINE_LINUX=\"cgroup_enable=memory swapaccount=1\"\nupdate-grub\nreboot\ncat /proc/cmdline 进行验证\n\n在Docker-Compose中禁止Swap\n\n参考资料\n\nEnabling memory cgroup in Ubuntu 20.04\nDocker -- WARNING: No swap limit support\ndocker container 容器资源限制\nSwappiness详解\n\n","path":null},{"url":"https://yzzfo.github.io/blog/在ASP的IOC实例化对象时加入自定义参数/","title":"在ASP的IOC实例化对象时加入自定义参数","description":null,"body":"  在使用IOC时我们能十分方便的去实例化一个对象而不用考虑其依赖的实例化方式，但有时候我们可能需要对依赖进行一些定制化的操作，这时候实例化依赖时就需要运行时才能确定具体的参数了，但在IOC整体的流程之中并没有一个地方供我们去输入这个参数，于是我们可以考虑设计一个工厂类来实现这个需求。\n相关API\n\nActivatorUtilities.CreateInstance 用于配合IServiceProvider实例化对象\n在ASP中制作一个基于IOC的单例系统\n\n实现方式\n工厂类方式\n工厂代码\n\n使用方式\n\n拓展方法方式\n拓展方法\n\n使用方式\n\n总结\n  虽然两种方式均可以实现该功能，但个人还是偏向于工厂类来实现，因为当使用工厂类时将会注入一个更为明确的依赖，而不像拓展方法中注入的IServiceProvider一样，毕竟当拿到IServiceProvider时就获得了访问所有对象的能力。\n","path":null},{"url":"https://yzzfo.github.io/blog/在ASP中制作一个基于IOC的单例系统/","title":"在ASP中制作一个基于IOC的单例系统","description":null,"body":"  单例是一种经常会见到的设计模式，但是单例对于新增接口以及之后的修改并不太友好(比如多个单例都实现同一个接口)，我们可以通过将其纳入到IOC中使得忽略该接口的实现细节(单例或者每次都实例化)直接获取接口对象，方便我们的管理。\n环境\n.NET 7.0\nSdk=\"Microsoft.NET.Sdk.Web\"\n关键API\n构建阶段\n\nWebApplicationBuilder  管理服务和配置的构建者\nIServiceCollection           服务相关的注册\nConfigurationManager  配置相关的注册\n\n运行阶段\n\nIServiceProvider  用于获取服务的接口\nIOption            IOptionX均用于获取配置\nIOptionSnapshot\nIOptionMotion\n\n获取配置时采用IServiceProvider.GetService&lt;IOptionX&gt;方式获取\n制作一个基于IOC的单例系统\n  在ASP的mvc框架下，他的controller只需继承ControllerBase以及标记对于的Attribute就会在运行时自动注册上对应的路由，我们制作的单例系统也将实现类似的效果。\n实现SinglontonAttribute\n\n实现SinglontonAttribute的拓展方法\n\n使用方法\n\n实现一个简单的定时任务\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/在Sonarr中使用Thexem-Proxy自定义数据/","title":"在Sonarr中使用Thexem-Proxy自定义数据","description":null,"body":"环境\n\nubuntu22.04\nsonarr 3.0.9.1549\n\n起因\n在获取动漫数据时发现部分动漫没有Alternate Titles，于是想自己添加合适的Alternate Titles用于搜索(当前sonarr只会使用全英文的Title去搜索，会跳过非英文的Title)，查看源码后发现Sonarr是使用thexem.info来获取scene mapping数据的，但thexem.info只能是注册用户才能进行修改于是找到了thexem-proxy这个项目来解决这个问题。\nDocker-Compose\n\nxem-mapping.yml\n\n配置DNSMASQ\n\nNginx\n\n申请自签证书\n\n\n\n\n\n\n配置Sonarr信任证书\n到sonarr中执行如下命令即可\n\n参考资料\n\nmono-ssl-issues\nCreate a Self-Signed Certificate for Nginx in 5 Minutes\n\n","path":null},{"url":"https://yzzfo.github.io/blog/V2ray笔记/","title":"V2ray笔记","description":null,"body":"一些不错的工具\n\nmulti-v2ray\nx-ui\n\n使用nginx反代x-ui\n\n在x-ui启用ws形式的代理(不用开启tls)\n在nginx中反代刚刚的ws即可\n\n\nunblockmusic\ndocker-compose.yaml\n\nconfig.json\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Tabby-Web/","title":"Tabby-Web","description":null,"body":"有时候通过SSH连接国外VPS的时候总是容易掉线，或者被阻断，这个时候就想通过web端来直接连接VPS在网上多方寻找后发现有几个不错的项目(webssh,tabby-web)可以用来实现这个需求，其中webssh部署十分简单，但界面稍微简陋了一些，tabby-web则拥有美观的界面，但部署的时候有不少问题需要解决，本文主要记录一下tabby-web部署过程中遇到的问题。\n\n拉取tabby-web仓库 git clone https://github.com/Eugeny/tabby-web.git\n通过docker-compose安装tabby-web\n\n安装tabby-web应用 docker container exec tabby /manage.sh add_version 1.0.171-nightly.3 ，由于上面的配置都是拉取自最新的代码所以值1.0.171-nightly.3是根据https://app.tabby.sh中的版本号得出。\n登录tabby-web并进行配置\n\n在gateway相关的设置中输入tabby-connection-gateway地址\n不同于桌面端 这里连接ssh时是直接输入 root@xxx.com 的而不是ssh root@xxx.com,后边的输入会被认为用户名是ssh root\n相关的选项配置https://github.com/Eugeny/tabby-connection-gateway#all-options\n\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/nftables/","title":"nftables","description":null,"body":"v2ray 透明代理案例\nip route add local 0.0.0.0/0 dev lo table 100\nip rule add fwmark 1 table 100 nftable 标记为1的走table 100的规则匹配路由\n\n\n参考资料\n\nhttps://xtls.github.io/document/level-2/iptables_gid.html#_4-%E8%AE%BE%E7%BD%AE-iptables-%E8%A7%84%E5%88%99\nhttps://www.cnblogs.com/sparkdev/p/11417781.html\nhttps://guide.v2fly.org/app/transparent_proxy.html#%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4\nhttps://icloudnative.io/posts/use-nftables-as-firewall/\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Calibre-Web/","title":"Calibre-Web","description":null,"body":"Calibre-Web是一个开源的电子书管理系统，最近重新部署到主机上用来整理本地的电子书，但在使用过程中遇到了一些小问题，这里记录一下。\n无法找到数据库\n之前安装的technosoft2000/calibre-web这个版本的容器，但看简介作者已经不再维护了于是使用linuxserver/calibre-web这个版本的容器，安装好后输入默认的账号admin密码\nadmin123进入初始化界面，此时选择数据库文件夹会出现找不到数据库这个报错，原因是该项目默认你是有一份calibre数据库的，这里可以选择去下载一个calibre桌面版用其生成metadata.db文件将其放入对应文件夹即可，或者下载一份空的metadata.db文件放入对应文件夹即可。\n也可以使用如下方式生成metadata.db\n\n上传书籍出现 database is lock\n该原因是sqlite使用metadata.db文件存放在cifs文件中需要调整挂载参数添加nobrl即关闭字节锁，之后即可正常使用。\n参考资料\nhttps://stackoverflow.com/questions/39533648/sqlite3-access-to-mounted-db-file-database-is-locked\n","path":null},{"url":"https://yzzfo.github.io/blog/FFmpeg/","title":"FFmpeg","description":null,"body":"错误检测\n  最近在使用Jellify的时候发现有些影片存在问题，于是打算写个脚本检测一下所有视频，既然要涉及的影音那就不可避免的要接触到FFmpeg这个项目了，只是为了检测视频是否有错误其实还是比较简单的，但其中还是有一点坑需要注意。\n\n\n安装 apt-get install ffmpeg\n\n\n错误检测 ffmpeg -v error -i /path/to/file -map 0:1 -f null -\n\n\nshell脚本\n\n\n\nFastStart\n  最近购入了一台Servarica的大盘鸡，在使用nplayer在线播放动漫时发现首帧加载的速度有点慢，于是研究了一下相关的解决方法，最终选择使用FFmpeg对MP4进行faststart处理，对于这种没有GPU的vps来说也是最快捷的方式了，配合unmanci就可以实现自动化faststart。\n\n常见的一些操作\n\nBT下载的视频中间存在错误或者缺失，可以使用如下指令将这些部分剔除ffmpeg -err_detect ignore_err -i input.mp4 -c copy output.mp4\n\n参考资料\n用ffmpeg快速校验目录内的视频文件的完整性 | Shura's自留地\nThe Linux LS Command – How to List Files in a Directory + Option Flags\n使用awk命令获取文本的某一行，某一列_姥爷wvb的博客-CSDN博客_linux提取某一列\nshell脚本逐行处理文本文件_Raily_Qi的博客-CSDN博客_shell逐行处理文件\nShell： Shell中while循环的陷阱, 变量实效, 无法赋值变量\nShell数组：Shell数组定义以及获取数组元素\nshell遍历数组3种方法 - 简书\nbash - Why does FFmpeg require nostdin in while loop? - Super User\nlinux - 'while read' loop through lines in text file losing characters in Bash script. is FFmpeg line to blame? - Super User\nDetect if \"faststart\" has been applied to video\nMake MKV file suitable for streaming with ffmpeg\n","path":null},{"url":"https://yzzfo.github.io/blog/PVE笔记/","title":"PVE笔记","description":null,"body":"  最近使用Emby的时候发现CPU占用率奇高，发现是在Exsi下N6005的核显并没有参与到硬解的工作中去，于是在网上多方搜索发现最新的PVE7.2似乎是可以LXC容器的形式来使用核显硬解，所以在这里记录一下使用PVE的过程。\n安装PVE\n  PVE就是一个Debian的定制版，安装过程和其他操作系统没什么区别，主要记录一下安装后的相关设置。\n\n\n设置直通特性\nnano /etc/default/grub\n替换GRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"\n为 GRUB_CMDLINE_LINUX_DEFAULT=\"quiet intel_iommu=on\" amd的cpu则将inter改amd即可\nupdate-grub\nnano /etc/modules\n填入如下内容\n\nupdate-initramfs -u -k all\n重启PVE\n\n\n安装Openwrt\n\n以上代码102对应的为虚拟机， /var/lib/vz/template/iso/openwrt.img对应的是上传的路径\n\n\n宿主机挂载磁盘\n\nhttps://pve.proxmox.com/pve-docs/chapter-pvesm.html\n\n\n\nfstab\n\n\n安装LXC容器\n  为了使用核显，这里选择Debian11的模板进行安装。\n\n\n更新内核至5.17.5\n\n\n\n查看当前内核\n\n\n\n安装Debian11模板，创建时取消非特权容器的勾选\n\n\n挂载核显（在PVE的shell中执行）\n\n\n\n在Debina11中安装nyanmisaka/jellyfin:latest的docker容器，该容器携带了相关核显驱动，emby经过尝试发现还无法正常驱动核显，挂载docker时要进行设备挂载，在docker-compose中如下配置\n\n\n\nsamba挂载\n在LXC中挂载Samba和通常系统下挂载有些许不同，在LXC中非特权容器需要在高级选项中勾选samba才可以使用，但无论是特权还是非特权均无法让其开机自动挂载抑或是使用x-systemd.automount这个选项来进行按需挂载，解决方法是在PVE上进行samba挂载，之后映射到LXC中，以LXC容器101为例\n\n\n\n黑群晖\n由于网上黑群晖安装方式感觉十分多样，于是先记录一下自己在PVE中安装黑群晖时的方法\n\n\n下载引导 黑群DSM7.X引导文件（2022年6月3日更新） - GXNAS博客\n\n\n创建虚拟机，使用qm importdisk将引导载入虚拟机，并选择SATA模式\n\n\n挂载另一款硬盘至虚拟机上用作存储\n\n\n开机后查看局域网内的群晖IP进入web后台\n\n\n根据web的安装引导下载对应的系统\n\n\n断开网络之后在进行系统安装\n\n\n参考资料\n\n\nn5105-pve-lxc-docker-jellyfin命令行.txt - Google 云端硬盘\n\n\nVLOG | PVE全新奶妈保姆级+爱快+openwrt+黑群晖7.0.1 +直通+IPV6+MAC地址重复修复\n\n\nProxmox VE 6/7 配置源及关闭订阅提醒\n\n\nLXC安装JellyFin并轻松开启硬件编码 - TimZhong's Blog\n\n\n如何在pve的lxc容器中挂载nfs目录\n\n\nProxmox VE（PVE）进行硬盘扩容操作教程 - 方舟基地\n\n\npve最小化安装docker之lxc下安装 - 郑道杰 - 博客园\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/编译Openwrt/","title":"编译Openwrt","description":null,"body":"  最近在使用eSir的固件时总是有各种各样的小地方并不能满足自己的需求，于是打算自行来编译lede的openwrt。现在网上主要有两种编译方式，一种是使用Git Action来进行编译，另一种是本地下载lede的库来自行编译，Git Action方式也只是基于CI对编译步骤进行了一定程度的封装而已，所以先采用本地编译的方式来进行固件构建。\n本地构建\n\n\n搭建Ubuntu LTS环境\n\n\n安装依赖\n\n\n\n下载源码\n\n\n\n(option)自建feed\n\n\n\n修改feeds.conf.default\n\n\n\n安装feed\n\n\n\n自定义配置\n可在项目根目录下创建files目录，该目录即会对应到镜像中的/目录\n更多可参考\n请教各位如何把个性化的config文件编译到img里\nopenwrt 更改默认主题 - hbg-rohens - 博客园\n[OpenWrt]源码编译修改默认IP地址和网关DNS地址 | α-LIB\n\n\n下载 dl 库，编译固件 （-j 后面是线程数，第一次编译推荐用单线程）\n\n\n\n二次编译\n\n如果需要重新配置：\n\n\n\nGitAction 构建\n\n\nhttps://github.com/esirplayground/AutoBuild-OpenWrt#autobuild-openwrt\n\n\n在手动构建的lede文件夹中执行./scripts/diffconfig.sh &gt; diffconfig，将diffconfig中的内容替换掉AutoBuild-Openwrt项目中目标架构的config文件\n\n\n修改workflow中yaml文件使其运行\n\n\n具体可看该视频[🔥🔥Video Tutorial (in Mandrin) | 视频教程(国语)📺🎉](https://youtu.be/9YO7nxNry-4)\n其他资料\n转盘后在esxi里添加现有硬盘不能识别出来文件\n求助，LEAN源码中修改默认登录密码的方法-恩山无线论坛 - Powered by Discuz!\n手动生成Linux密码（/etc/shadow） - 哈希\n","path":null},{"url":"https://yzzfo.github.io/blog/Linux Disk/","title":"Linux Disk","description":null,"body":"  最近在使用exis时经常要使用到关于磁盘操作的指令，故在此记录一下这些指令的使用场景和用法。\n运行环境\n\n\nexsi 7.0.3\n\n\nubuntu-22.04-live-server-amd64\n\n\n安装ubuntu时选择了Set up this disk as an LVM group\n\n\n创建新的分区\n在使用exsi时，如果我们后续给ubuntu新增一块硬盘时需要在ubuntu中对其分区格式化操作后才能使用，其具体步骤如下。\n\n\nfdisk -l 找到形如下边的Disk，这既是刚刚挂在上去的磁盘\n\n\n\nfdisk /dev/sda 为磁盘创建分区，具体操作可参考该博文Ubuntu如何新建分区\n创建后使用fdisk -l查看可以看到新增的Device\n\n\n\npartprobe 同步分区表至系统\n\n\nmkfs.ext4 /dev/sda1 格式化分区\n\n\nmkdir /mnt/disk 新建挂载目录\n\n\n添加/dev/sda1 /mnt/disk ext4 defaults 0 1至/etc/fstab文件\n\n\n\nmount -a挂载全部文件\n\n\ndf -h查看挂载情况，出现def/sda1即成功挂载\n\n\n\n扩容现有磁盘\n  在ubuntu编译openwrt时，编译到最后出现磁盘空间不足的报错，于是需要给现在挂载的磁盘进行扩容操作，此处假设扩容2G。\n\n\n在exsi给指定磁盘分配更大的空间\n\n\n分区大小调整\n\n\n使用gparted调整分区大小，具体操作参考Ubuntu server在ESXi下进行磁盘无损扩容\n\n\n使用parted扩容\n\n\n\n使用gdisk调整分区大小\n\n\n\n\n\nlvdisplay 显示逻辑磁盘，此处可以知道逻辑磁盘路径为/dev/ubuntu-vg/ubuntu-lv\n\n\n\npvdisplay 查看物理磁盘路径\n\n\n\nvgs 查看vg空间是否满足LV扩容\n\n\n\n扩容\n\n\nlvextend -L +2GB /dev/ubuntu-vg/ubuntu-lv\n\n\nlvextend -L +100%FREE /dev/ubuntu-vg/ubuntu-lv\n\n\n\n\nresize2fs /dev/ubuntu-vg/ubuntu-lv重新加载逻辑卷\n\n\ndf -h查看结果即可\n\n\n参考资料\n\n\nLV扩容(lvextend) - 简书\n\n\nUbuntu server在ESXi下进行磁盘无损扩容 - ericdee - 博客园\n\n\nEsxi上Linux虚拟机硬盘（LVM）扩容文档\n\n\nUbuntu如何新建分区\n\n\nProxmox VE（PVE）进行硬盘扩容操作教程 - 方舟基地\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Openwrt中的DNS/","title":"Openwrt中的DNS","description":null,"body":"在Openwrt中有许多关于DNS的设置，为了理清各种关系和流程，故在此记录一下。\n基础DNS设置\n\nWan口DNS设置: 路由器访问网络时使用的DNS地址\nLan口DNS设置: DHCP下发给其他设备的DNS地址\nDHCP/DNS该功能其实是dnsmasq，其uci对应/etc/config/dhcp.conf\n3.1 DNS 转发: 将请求本地53端口的请求转发给设置的DNS\n3.2 解析文件: 通常该文件是/tmp/resolv.conf.d/resolv.conf.auto,该文件中的DNS地址为Wan口中的DNS地址。\n3.3 两个选择之间的关系: 经过测试，只要其中一个选择设置正确即可通过使用nslookup获取到解析的域名，故推测两者为并行关系。\n\n总结\n  对于设置静态DNS的人来说，这几个选项对其没有任何影响，只有当Lan口DNS设置为当前路由IP或者不填时（默认路由IP），其他机器才会访问dnsmasq进而产生影响。\nDNS防污染\n  由于通常情况下DNS是明文传输很容易做到篡改，也就造成了国内去访问国外域名时很容易获取到受到污染的IP地址，这种情况下就两种选择，一种是直接本地解析域名即host文件，另一种走加密的DNS，本地解析这种方法过于粗犷，所以还是采用加密DNS，但为了DNS能够有更好的速度应该采用特定域名查询采用加密，正常的域名走老方法。\ngfwlist\n  gfwlist是一个包含了大量国内被墙或污染的域名列表，通过它我们可以获取什么域名应该走加密的DNS请求。\nSmartDNS\n  SmartDNS是一个本地DNS服务器，可以设置多个上游DNS服务器，它自带两个DNS服务器设置，这正是我们想要的，一个用来走加密查询，一个用来走常规查询。\nSmartDNS的配置文件\n位置: /etc/config/smartdns\n\n在上游DNS设置中server_group为proxy的均选择了支持https的DNS服务器，\n在该配置中6335端口用于之后访问在gfwlist以外的域名，5335则访问gfwlst之内的域名。\nSSR Plus\n  是一款代理软件，其支持使用gfwlist进行分流操作，在运行模式选择GFW运行模式以及DNS解析方式中选择使用本机端口为5335的DNS服务，即可当收到包含在gfwlist中的域名需要进行DNS查询时将会走到SmartDNS的5335服务中去。\nSSR Plus分流的原理\n  SSR Plus分流是基于dnsmasq实现的，具体可查看/var/dnsmasq.d/dnsmasq-ssrplus.d下的文件，在该文件夹下面包含了许多生成的dnsmasq的分流规则\n\n可以看到这些规则不但定义了分流规则，也为之后的代理对ip进行了分类，后续通过iptable将所有处于gfwlist集合中的ip转发给代理。(ipset list 可以看到所有集合)\nDNS查询代理\n  分流过后DNS污染其实是已经解决了，但返回的IP其实是离我们当前路由器最近的节点，这是由于我们查询时是使用我们本机的IP查询的，为了让代理服务器访问最适合他的IP，我们应该让代理服务器去查询DNS，这时候我们应该让DNS的查询请求也走代理才可以。\nDNS走代理有几个注意点:\n\n例如 https://dns.google/dns-query这个https的DNS查询服务，如若加密分流都是这种域名类型的，要使用这个查询服务就必须先解析dns.google这个域名，所以我们不能让dns.google这个域名的查询走当前设置的加密分流，因为这将陷入死循环，为了解析dns.google而去通过dns.gooogle解析dns.gooogle。只有当存在明确IP地址的dns存在时才能让其走加密，否则将陷入循环之中。\n尽量直接使用IP地址类型的DNS，这样就可以直接在代理中强制设置IP走代理，也无需注意第一点中的问题了。\n代理服务器的域名解析不可走代理。\n\ndnsmasq设置\n  在SSR Plus仅仅设置了处于gfwlist内时的行为，需要在dnsmasq中修改默认行为来适配gfwlist外的域名，dnsmasq中将DNS 转发设置为127.0.0.1#6335同时关闭解析文件即可。\n在 OpenClash 中设置 AdGuard\nDNS 查询顺序 Client =&gt; OP: 53 =&gt; AD =&gt; OpenClash\n之所以 AD 要位于 OpenClash 之前是因为 OpenClash 在查询需要代理的域名时将采用远程解析，即跳过上游 DNS 直接转发至代理服务器去解析 DNS。\n所以设置方法为，AD 中设置劫持 53 端口，将上游 DNS 设置为 OpenClash 即 127.0.0.1:7874 在 OpenClash 中关闭 DNS 劫持，并设置上游 DNS。\n参考资料\nLean OpenWrt DNS解析流程研究\ndnsmasq ipset iptables 实现对流量进行分流\n","path":null},{"url":"https://yzzfo.github.io/blog/Linux笔记/","title":"Linux笔记","description":null,"body":"指令\n\niptables https://blog.csdn.net/qq_41453285/article/details/102734347\nnetstat http://ubuntu.digitser.net/ubuntu/zh-CN/netstat.html\nawk https://blog.csdn.net/qq_42698422/article/details/100087118\ncurl http://manpages.ubuntu.com/manpages/trusty/man1/curl.1.html\n\nSwap\n\n查看进程swap使用情况 smem -k -s swap\n创建swap\n\n\n一些坑点\n\n连续使用管道\n\n\n例子\n\n日志监控\n\n\n永久设置DNS\nhttps://www.tecmint.com/set-permanent-dns-nameservers-in-ubuntu-debian/\n\nShell 下脚本变量问题\n\ncp显示进度\n参考\n\nmv文件\n在使用rclone的时候，直接使用mv可能会存在无法ctrl+c进行中断，这时候使用rsync可以很好的解决这些问题，同时还可以显示进度\n\n","path":null},{"url":"https://yzzfo.github.io/blog/All in one 软路由/","title":"All in one 软路由","description":null,"body":"  昨天N6005主机到了于是学习了一下如何让其作为主路由来使用。如果直接硬件刷Openwrt的话主路由的设置还是比较容易的，就是一个网口连外网充当wan，一个连内充当lan罢了，但鉴于这样实在是浪费了N6005的性能还是要上ESXi才行,EXSi就是VMware的一个虚拟机系统，依托该系统来让主机有更多的功能支持。\nEXSi的安装\n  具体安装过程参考 vSphere ESXI 7.0部署详细安装指南，奶妈级安装教程(附镜像)\n拓扑设计\n  由于后续系统都将基于EXSi来进行安装，所以在这先进行网络的拓扑设计。\n\n网口设置\n  由上边拓扑可以确定现在的EXSi的网口应该进行如下设置\n\neth0 保持原本的虚拟模式\neth1，eth2，eth3设置为直通模式\n为了后续也能在eth1，2，3中接入的设备也能进入EXSi管理界面，需要打开虚拟交换机的混杂模式。\n可参考该视频\n\n   \nIP设置\n\n首先将Exsi设置为静态IP 这里以 192.168.3.2 为例，网关设置为192.168.3.1\n电脑若连不上，则需要手动设置电脑IP到192.168.3.x网段\n后续的Openwrt中lan设置为192.168.3.1\n\nOpenwrt安装\n  Openwrt的固件这边选择eSir编译的固件,固件下载好后配合img转vmdk工具starwindconverter来生成EXSi所要使用文件，具体参考img转vmdk步骤以及安装  至此就完成了Openwrt的安装，其他设备应该也能正常上网了，若无法正常上网可能是固件原因，尝试换个版本看看。\n安装其他系统\n  安装其他系统只需要使用默认网卡配置即可，这样所有设备都将走Openwrt来进行网络处理了，这样基于EXSi的主路由就告一段落了\n其他的一些坑\n  本来准备给这个主机配一个1T的固态的，在淘宝中买了七彩虹CN600，没想到居然不兼容，这也是太难得了，后来在群里询问后获得一个兼容表单，里面还一个不兼容的品牌就是爱国者，看来国产芯片的兼容性还有待提供啊，以后还是老老实实的买正统牌子吧。\n","path":null},{"url":"https://yzzfo.github.io/blog/Telegram Widget/","title":"Telegram Widget","description":null,"body":"   几个月之前使用Telegram Widget发现其使用免费域名tk,ml,ga时点击登录无任何反应，今天没事又试了一下发现可以使用免费域名ml登录了，于是来这记录一下在操作的过程中踩到的一些问题。\n\nRefused to frame 'https://oauth.telegram.org/'\n   这个问题的原因在于在本地调试时使用了非80,443的端口号，参考\n一直登录不上\n   通常需要清理浏览器缓存重新点击widget在测试或者使用无痕模式，无痕模式每次启动时重新开一个页面进行测试反正缓存问题，然后要到telegram中将前面的登录给处理了否则可能影响到后续登录。\n本地https调试\n   原本以为第一个问题时由于本地采用的http导致的，于是找到了mkcert这个项目，可以用来本地安装证书生成密钥,之后只需要在服务端引入密钥即可。\n\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/ThrottleStop/","title":"ThrottleStop","description":null,"body":"  最近玩游戏发现电脑十分频繁的降频，检测温度发现CPU和GPU均达到了90°以上，在替换完硅脂之后GPU的温度有了明显改善但CPU还是存在问题，在性能管理器中发现CPU经常会跑满睿频，玩游戏其实是用不上如此高睿频的于是乎想着能不能限制住最高睿频使得温度可以保持在一个正常范围内于是找到了ThrottleStop这款软件\nThrottleStop的使用\n  ThrottleStop是一个可以用于调节电脑功耗的软件，提供了许多配置用来设置电脑性能。\n\n选项说明\n\nSet Multiplier 设置倍频 如CPU 2.2GHz则设置为22 8750H似乎是不支持这个功能的\nSpeed Shift - EPP 值：0-255 用于设置电脑性能偏好 0则是注重性能 255则是节能\nDisable Turbo 禁用睿频\nBD PROCHOT 开启后 GPU温度过高将导致CPU降频\nFIVR 集成电压控制面板\n\n5.1 Core Active即可调节睿频最大速率\n\n","path":null},{"url":"https://yzzfo.github.io/blog/雨中冒险mod制作/","title":"雨中冒险mod制作","description":null,"body":"最近开始玩起来了雨中冒险2这款游戏，发现这款游戏是使用Unity制作的而且还支持Mod于是就打算来修改修改游戏内的逻辑。\n雨中冒险Mod环境安装\n\n下载 BepInExPack 并解压至游戏根目录\n安装 R2API 放在**Risk of Rain 2/Bepinex/plugins/**目录下\n\n新建Mod项目\n\n使用Rider创建新的C# Class Library项目，Framework选择netstandard 2.0，SDK选择3.0以上。\n创建插件\n\nBuild该工程，在Risk of Rain 2/Bepinex/plugins/目录中创建文件夹并将Build后的dll文件放入其中，至此Mod安装完毕。\n\n\n\n断点调试Mod\n\n安装dnSpy\n查看游戏使用的Unity版本\n\n查看Risk of Rain 2\\MonoBleedingEdge\\EmbedRuntime\\mono-2.0-bdwgc.dll PE头中的时间戳\n3.1 方法一：使用dnSpy查看时间戳，该时间戳为本地时间\n\n3.2 方法二：使用umpatcher查看时间戳，见第七步中的使用\n拉取dnSpy-Unity-mono并切换到dnSpy分支\n拉取Unity-Mono并找到对应Unity版本的的分支\n例如v5.4.3, 分支名为unity-5.4， 结尾带-mbe使用 .NET 4.x assemblies\n找到和时间戳最接近的提交，复制hash\n编译umpatcher\n在dnSpy-Unity-mono中的找到src\\umpatcher\\umpatcher.sln使用visual studio打开并Build即可\n使用umpatcher\n\n编译mono-2.0-bdwgc.dll\n打开dnSpy-Unity-mono目录找到dnSpy-Unity-mono-v2019.x-V40.sln，用Visual Studio打开，选中里面的项目2019.4.26-mbe进行生成即可获得mono-2.0-bdwgc.dll\n用获得的mono-2.0-bdwgc.dll将游戏中的mono-2.0-bdwgc.dll文件进行替换\n用dnSpy进行运行游戏\n10.1. 选择调试-&gt;开始调试\n10.2. 进行如下设置\n\n拖入想调试的dll，断点即可\n\n参考资料\nhttps://github.com/dnSpy/dnSpy/wiki/Debugging-Unity-Games\nhttps://github.com/dnSpy/dnSpy-Unity-mono#supporting-a-new-unity-version-for-dummies\nhttps://github.com/risk-of-thunder/R2API/wiki\nhttps://github.com/wonoton/Risk-of-rain-2-Mod-Guide\nhttps://riskofrain2.fandom.com/wiki/Modding\nhttps://github.com/risk-of-thunder/R2Wiki/wiki\nhttps://www.aoe.top/mod/405\nhttps://github.com/BepInEx/BepInEx.Debug\nhttps://github.com/ManlyMarco/RuntimeUnityEditor#readme\n","path":null},{"url":"https://yzzfo.github.io/blog/在Unity中翻转Mesh制作空气墙/","title":"在Unity中翻转Mesh制作空气墙","description":null,"body":"  有时候我们想将角色限制在一个闭合物体内部，这时我们可以通过翻转该物体的mesh达到我们期望的效果。\n前置知识\n\nunity采用左手坐标系\n对于一个三角面，通过左手螺旋得出的法线方向即为正面方向。\n在unity默认设置的情况下，对于一个三角面来说，只有正面才有碰撞检测。\n\n解决方法\n方法一：直接在blender中翻转法线即可\n方法二：通过代码翻转顶点顺序\n\n至此角色便可以在物体内部移动，在边缘时会产生正确的碰撞。\n拓展\n在遇到类似黑魂中的雾门时(单面墙)也可以采用类似的，区别在于雾门只需要一片mesh即可。\n","path":null},{"url":"https://yzzfo.github.io/blog/使用Camera生成Stencil/","title":"使用Camera生成Stencil","description":null,"body":"  有时候我们想让某个Layer上的所有物体都作为Stencil时就需要使用一个新的Camera用以渲染出对应的Stencil。\n环境\n\nUnity2020\nStandard Render Pipline\n\n相关API\n\nCamera.Render 手动调用相机的渲染，该相机必需是disable的\nCamera.SetReplacementShader 让该相机渲染的物品都使用指定Shader\nCamera.ResetReplacementShader 清除SetReplace的设置\nCamera.SetTargetBuffers 设置该相机渲染结果存到哪\nCamera.CopyFrom 复制另一个相机的设置\nGL.Clear 清除RenderTexture.active中的内容\nRenderTexture.DiscardContents 清理RenderTexture中的内容\n\n思路\n\n将用于渲染Stencil的Camera挂载于Main Camera之下\nStencil Camera使用CopyFrom复制Main Camera的设置\nStencil Camera的clearFlags设置为CameraClearFlags.Nothing\nStencil Camera的cullingMask设置为对应的LayerMask\n在Main Camera中的OnPostRender时调用Stencil Camera的Render方法生成Stencil，之所以在OnPoseRender时调用是因为此时可以获取到正确的Depth Buffer。\n\n大体代码如下\n\n二值化图片Shader\n\n其他的一些问题\nRenderTexture\n关于new和GetTemporary\n这两个API均可以获得到一个RenderTexture，区别在于GetTemporary Unity 内部保留了一个临时渲染纹理池，因此对 GetTemporary 的调用通常只返回一个已经创建的纹理（如果大小和格式匹配）。这些临时渲染纹理在几帧未使用时实际上会被破坏。\n参考资料\nRenderTexture.GetTemporary\nRenderTexture.DiscardContents\n","path":null},{"url":"https://yzzfo.github.io/blog/Linux性能监控/","title":"Linux性能监控","description":null,"body":"今天在弄Drone的时候发现发现性能十分不稳定，同一个任务运行时间2-10分钟不等，差距实在是太大了，于是想看看问题出在哪里，找了一圈查看性能的工具所以在这记录一下。\n命令行工具\n\ntop 自带工具，用来看看CPU和MEM\niotop 用来查看当前IO占用的工具\nfree 查看内存统计信息\n查看进程swap使用情况 smem -k -s swap\n\nNetdata\n命令行工具通常也就是拿来看看当前情况如何，有时候想看看详细的数据统计或图表，这时候可以安装Netdata来完成该需求，Netdata是一个开源的方案，而且提供了前端界面用起来十分的方便，统计的数据也很详细。\n通过Docker Compose安装\n\n浏览\n浏览的方案有两种:\n1. 使用诸如Nginx或者Caddy之类的服务端进行反向代理以此来使用Netdata\n2. 在Docker部署时链接Netdata官方提供的服务，通过官网来查看详细数据\n\n登录 https://app.netdata.cloud\n注册并登录后找到Nodes相关选项\n选中Nodes选项后找到Docker相关的选项，复制里面提供的Docker代码在本机运行即可。\n安装完成之后在该网站就能看到服务器的性能数据了。\n\nIOSP\nIOSP意为磁盘每秒的读写次数，有些VPS厂家是会锁这个值，之前购买VPS的时候没怎么关注过这个性能指标，但最近使用Cloudcone的时候发现指令执行起来出奇的慢，最后使用https://github.com/masonr/yet-another-bench-script这个脚本跑了一下发现在4k block的情况下IOSP这个指标相较另一台服务器来说有巨大的差异(Cloudcone 100+,Servarica 15k+),于是出现一个很有意思的事情发生Servarica测出来的读写速度没Cloudcone快，但实际体验来看Servarica明显好很多，执行各种任务都没有明显延迟，而Cloudcone则是每次等几秒甚至数分钟才能有反应。在执行指令时Cloudcone的iowait会达到100%，而Servarica则基本为0。这就有点像是拿货轮送外卖的形象了，虽然读写大，但是每次间隔太长了。\n参考资料\n\nLearn Netdata\n25 个 Linux 性能监控工具\n\n","path":null},{"url":"https://yzzfo.github.io/blog/GOCV的安装/","title":"GOCV的安装","description":null,"body":"最近看到B站上有人讲解OpenCV发现里面只要很少的代码就能实现一个人脸识别感觉还蛮有意思的于是也打算玩一玩。一开始使用python来写的OpenCV,但由于是动态语言，代码补全功能实在是不好用所以改用Golang来使用OpenCV了。\n1. 编译OpenCV\n\n安装MinGW-64 下载posix-seh类型的\n安装CMake\ngo get -u -d gocv.io/x/gocv\ncd $GOPATH/src/gocv.io/x/gocv  若是1.14以上则安装到了pkg文件夹中了，可以通过关闭GOMOUDLE来使其安装到src目录中，或者下载后修改win_build_opencv.cmd文件中的相关路径\ngo run ./cmd/version/main.go测试是否成功\n\n2. 文档\n\nhttps://gocv.io/getting-started/linux/\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Hexo/","title":"Hexo","description":null,"body":"之前使用WordPress来构建自己的博客系统，奈何自己的VPS性能太孱弱了(1C1G)而且还要在Docker中运行使得要打开WP部署的网页都得几分钟，所以改用Hexo来构建自己的博客了，\nHexo和WP的区别就在于，Hexo是静态博客，WP是动态的，静态的好处当然就是只需要服务器直接发送文件给浏览器就行了，不需要动态去生成网页然后在发送给浏览器，这种只提供文件传输，其他东西都交给浏览器去干的方案正是我这台VPS所需要的。\n要使用Hexo首先应该大体了解一下他的工作流程，Hexo可以看作就是一个markdown转html的软件，但不同于Typora这种markdown软件的导出为html,Hexo导出时会进行一些额外的操作，比如构建文章的数据库等等的额外操作，并将这些数据和js进行关联，最终组成整个博客。也就是说Hexo导出的东西就两类，js构成的用户操作和数据。\n使用步骤\n\n安装Node.js\nnpm install -g hexo-cli\nhexo init [folder] 初始化hexo项目\nhexo new &lt;title&gt; 创建一篇markdown文章\n调试和部署\n\nhexo server 开启hexo服务,此时可在localhost:4000看到博客效果\nhexo clean &amp;&amp; hexo g -d hexo项目构建，将构建的结果即public文件夹上传到服务器即可完成部署\n\n\n\n额外功能\n\nNexT主题使用说明\nUUID\n数学公式\n\n","path":null},{"url":"https://yzzfo.github.io/blog/动画系统/","title":"动画系统","description":null,"body":"动画系统\nUnity中常用的Avatar有两种，一种是Generic另一种是Humanoid，Generic类型通常用于自定义骨骼，或者说如果有专门的一套骨骼制作则用Generic会好一些，Generic就是当纯的顶点映射，骨骼节点同名即可进行动画播放。Humanoid则采用骨骼映射的形式进行播放，通过将骨骼A映射到Unity的一个标准人体模型，通过这个中间层来映射给别的Humanoid骨骼进行播放。\n今天遇到一个问题就是现在有两个fps游戏模型素材，一个是第三人称用的射击动画，另一个是第一人称用的射击动画，他们两个都是用的同一套骨骼结构，但却无法在第一人称动画导入中使用import avatar from other导入第三人称的avatar来直接进行映射。\n\n\n第三人称和第一人称的骨骼如图所述，均为一样的结构，且模型本身也是由用一个mesh所组成，所以预想的方式为直接将第一人称的avatar设置为第三人称所生成的avatar，设置之后出现了问题，骨骼映射出现了巨大的Y向偏差，导致模型直接超出Skinmesh的渲染范围，到地底去了，如图所示\n\n\n产生该偏差的原因可能是第一人称动画本身就存在Hip节点的偏移，加之映射的缩放导致的\n之后选择用同一个模型进行Create From this mode操作来创建avatar\n\n\n打开第一人称模型的配置后会发现其及其混乱，这是由于第一人称的动作本身就扭曲导致的，仔细观察可以发现左边的arm都已经穿到右侧去了\n\n\n\n照着骨骼顺序将右侧的Unity标准骨骼结构填入，此处可通过保存第三人称的Mapping，在Load到第一人称简化操作，但在这里进行该操作后只能Mapping出上半身的映射，下半身没映射上去，不知是何原因，剩下一半就手动给拖进去。\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n\n\n填充好节点之后就是将模型摆成T-Post，这里通常可以通过Pose -&gt; Enforce Pose来摆成T-Pose，但Enforce Pose在这次的模型中无效，应该也是由于第一人称模型过于扭曲的缘故。\n\n\n既然Enfore Pose无效那么怎么来摆T-Pose呢，由于第三人称模型和第一人称模型骨骼一模一样，而且第三人称模型并不扭曲在avatar中正规的T-Pose模型，于是我们可以去他的Avatar Config中将他的模型拷贝出来，做一个T-Pose预制体，用来将里面各个节点的坐标赋值给第一人称的avatar。\n\n\n复制Avatar工具\n\n\n\n在第一人称的Avatar Config界面中将模型拖入To中，将第三人称的T-Pose，预制体拖入From中点击Copy即可\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n7.在场景中查看效果，可以发现动画Y轴的偏移对了，但肩膀位置不对，没有还原出第一人称时的扭曲\n\n\n\n\n要还原扭曲就得知道通常骨骼动画是怎么做的，通常在骨骼动画中我们只会对各个关节进行旋转，通过旋转来达到位移，也就是说骨骼是不会拉伸的。但在第一人称的动画中，我们可以发现，这肩膀是拉伸了的，也就是说，关节不但可以旋转，还位移了，这中东西在Generic动画系统中并没什么问题，应该Generic仅仅就是映射点，并不管其他的东西，但在Humanoid中默认骨骼是不允许位移的，这是就得开启Translation DoF选项，也就是开启位移这个自由度。第一人称和第三人称均要开启。\n\n\n\n\nHumanoid的原理测试\n假设我们有两个Humanoid的Avatar A和B 均为正规的T-Pose，现在我们想让B来播放A的动作，即A映射到B身上去，正常情况下B将正常播放B的动作，此时我们将A的Avatar的根节点向后转一转，即后仰个20度并保存，此时将会导致B前倾20度，这是由于A和B均通过Unity的中间骨骼即Avatar进行映射，可能是如下过程，由于A当前设置后仰20度的状态为他的T-Pose，即标准状态，但动画中A还是直立的，所以从T-Pose到动画中的状态需要A进行前倾20度，于是乎A要完成这个动作就变成了前倾20度并完成该动画片段，将这条指令映射到B上就导致B前倾了20度。\n同样我们不改动A，来改动B，将B的Avatar前倾20度，最终结果将是B前倾20度，这是因为前倾20度就是B的标准状态，一切动作都是依照标准状态来做的，那么A在直立时做的标准动作，到了B这就是B前倾20度来做这动作。\n关于Copy avatar from other 和 Create from this的猜测，估计Avatar中记录了骨骼的长度映射关系，对于不同的第三人称模型，使用同一个avatar均没问题，这便可以排除骨骼中的位置旋转的影响，他们唯一没变的就是骨骼长度，而第一人称由于骨骼拉伸，这也导致骨骼与第三人称不匹配，所以推测avatar保存的是骨骼长度映射关系，由于这个关系导致了偏移，在上面的案例中若同时开启DoF，使用Copy的动画将会有个很巨大的放大效果，估计也是这个原因导致的。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/AsyncMethodBuilder/","title":"AsyncMethodBuilder","description":null,"body":"之前说过await的原理是一个类似回调的东西，于是突发奇想能不能做一个符合如下条件的Awaiter:\n\n类似If语句可以判断是否执行后续逻辑\n类似Using在后续代码都结束时可以执行一个特定方法\n\n于是写了类似如下代码\n\n这段代码乍看感觉可以实现，但问题出在Task.Delay(300)这边导致回调并不阻塞，所以Reset将在await DoOrSkip()之后立马打印出来。\n后面有想到使用using+await组合，通过await返回一个IDispose在using结尾调用，但问题出在await作用域和using不一样，await若跳过将会把后续代码都跳过，using只在中括号范围内。\n所以后续找到了另一种方式——AsyncMethodBuilder用他来构建自己的await状态机\n在Unity2020.3中的.net2中缺少一个所需的Attribute需要添加如下代码\n\n然后构建自己的Builder\n\n在构造Task-Like对象\n\n这样就可以实现结束回调了，其余还有很多东西需要实现可以参考UniTask\n参考资料\nhttps://stackoverflow.com/questions/42721979/in-c7-how-can-i-roll-my-own-task-like-type-to-use-with-async\nhttps://devblogs.microsoft.com/premier-developer/extending-the-async-methods-in-c/\nhttps://github.com/Cysharp/UniTask\n","path":null},{"url":"https://yzzfo.github.io/blog/GPU Instance/","title":"GPU Instance","description":null,"body":"最近稍微接触了一些GPU Instance特此记录一下\n在顶点片段着色器内使用GPU Instance还是比较简单的，只需要把对应属性声明方式改成GPU Instance的声明方式即可。\n\n但在GPU Instance中不支持使用Texture2D作为Instance属性，解决方法是使用Texture2DArray,将Index作为Instance属性，默认情况下Texture2DArray会生成minimap深度，所以离远了会变原色，需要在生成时进行代码设置。\n参考资料\nhttps://www.cnblogs.com/hont/p/7258615.html\nhttps://docs.unity3d.com/Manual/GPUInstancing.html\n","path":null},{"url":"https://yzzfo.github.io/blog/T4模板/","title":"T4模板","description":null,"body":"最碰到了一些代码生成的需求，按以往的一些生成代码的简单方法就是使用string.Format来格式化一个字符串，但想来总觉得太暴力了，也没啥维护可言，于是网上搜了搜C#的代码生成方案发现了T4模板这个玩意。\n开发环境\n\nRider2021.2\nUnity2020\n\n要在Unity中使用T4需要在Eidt&gt;Preferences&gt;External Tools的Extension中添加后缀tt和ttinclude，并重新生成项目文件。\nRider在Unity中的插件版本更新为最新，在版本2.0.7中为当前Unity推荐版本，但使用T4有bug，时好时坏，更新到3.0.7就可以正常运行了。参考\n运行T4文件则是在Rider中选择T4文件 &gt; 点击T4文件编辑界面第一行左边的绿色三角形即可\n编写T4文件\nT4文件编写时可以直接使用C#代码，这样就可以在模板中直接调用开发环境的API来快速获得想要的数据了。\n简单的例子\n\n保存文件\n默认保存方式只能保存一份代码，保存的名字为T4文件名+定义的后缀。要同时生成多个文件需要进行相应的代码编写。\n一个简单的保存示例\n\n这种方式可以多文件保存，但默认保存方式的文件并不会因此就不再生成，所以通常会多出一个不想要的空文件，暂时也没找到什么有效的解决方法，索性在SaveOutput之后加入一些说明文本之类的，然它输出到这个默认文件中用作类似README的存在。\n引用Unity的Dll\n在T4中引用其他的Dll需要输入他们的路径，但不同的Unity版本他们的Dll所在的位置也有所不同，所以需要在Unity中设置一个环境变量用于表示该目录，这样T4模板中导入的路径就不用每次更换版本的时候进行改动了。\nEditor中进行基础设置\n\n使用环境变量\n设置环境变量后需要关闭编辑器，并通过在Unity中双击脚本重新打开编辑器才能使得环境编辑在编辑器中生效，之后通过如下方式在T4中导入dll。\n\n\n%XXX%  格式只能用于环境变量\n$(XXX) property和环境变量都可以使用\n\ncsproj中设置Property\n\n\nT4使用反射时对象为MonoBehaviour时出现错误，提示无法加载netstandard.dll\n出现错误时的Csproj\nC:\\Program Files\\Unity\\Hub\\Editor\\2020.3.42f1\\Editor\\Data\\MonoBleedingEdge\\lib\\mono\\4.7.1-api\\Facades\\netstandard.dll\n正常的Csproj\nC:\\Program Files\\Unity\\Hub\\Editor\\2022.3.4f1\\Editor\\Data\\NetStandard\\ref\\2.1.0\\netstandard.dll\n原因在于.NetFramwork的选择 4.x时会出现错误路径，需要使用2.1\n参考资料\nhttps://docs.microsoft.com/zh-cn/visualstudio/modeling/writing-a-t4-text-template?view=vs-2022&amp;redirectedfrom=MSDN&amp;viewFallbackFrom=vs-2015\nhttps://stackoverflow.com/questions/33575419/how-to-create-multiple-output-files-from-a-single-t4-template-using-tangible-edi\nhttps://learn.microsoft.com/en-us/archive/msdn-magazine/2012/may/t4-templates-managing-complexity-in-t4-code-generation-solutions\nhttps://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2015/modeling/t4-assembly-directive?view=vs-2015&amp;redirectedfrom=MSDN\n","path":null},{"url":"https://yzzfo.github.io/blog/Unity中的同步异步/","title":"Unity中的同步异步","description":null,"body":"最近看接触xlua时发现一个挺有意思的例子,该例子中将原本的异步逻辑变为了同步逻辑,xlua中的实现是基于lua协程，于是我也想试一试在C#中实现类似的功能，lua协程简单来看也就是改变了调度顺序而已，看起来就像将异步方法放yeild中回调后续内容一样，在C#中类似的概念就是async和await，Unity在2017后就支持了C#中的async和await关键字，于是开始尝试着使用这两个关键字去实现这种功能。\nasync和await\n使用规则\n\n\nasync\n\n\n\nawait\nawait属于编译范畴的内容，可以被await的对象要符合一下条件\n\n存在一个GetAwaiter方法，该方法可以是对象自身的也可以是拓展方法，返回一个Awaiter对象\n\nAwaiter对象也是一个编译范畴的概念，也要符合如下条件\n\n继承INotifyCompletion接口\n存在一个GetResult()方法，返回类型不限\n存在一个IsCompleted的bool变量或属性\n\n\n\n\n\n一个基本的例子\n\n\n\nawait的调用逻辑\n先从await的调用逻辑看起\n\nC#中实现xlua的asyncTosync\n通过await的调用逻辑就不难发现，他其实和lua协程基本一样，await也不过是个委托封装器，专门把后续代码封装成委托的一个关键词罢了，那么思路就变成了通过await将后续方法注册给对应要等待的回调\n伪代码\n\n实现线程同步\nUnity中经常要进行线程同步操作，比如常用的事件模型，若想在网络回调中使用则需要在其中加入线程同步操作，通常来说都是维护一个任务队列之类的东西来进行同步，但通过awiat可以很容易实现线程切换。\nawait线程切换本质也就是把下文委托传递给不同线程去调用。\n\n主线程\n\n线程池\n线程池思路也和上变一样，就是改变OnCompleted中的调用线程而已。\n\nC#中Task的一些东西\nTask是C#中自带的一些Await实现，他们大都执行时在调用时的SynchronizationContext.Current中，也有一些比如await Task.Delay(10)改变线程，究其原因在于Delay是采用另一线程来执行计数的，如果不是另一个线程那么也就阻塞本线程其他的东西了，那么async也就没什么意义了。\n参考资料\nhttps://www.jacksondunstan.com/articles/4918\nhttps://gametorrahod.com/unity-and-async-await/\n","path":null},{"url":"https://yzzfo.github.io/blog/Selenium的使用/","title":"Selenium的使用","description":null,"body":"Selenium的使用\nSelenium虽然以前就接触过，但从未在Liunx服务器上去使用过，故在此记录一下在Linux下踩到的坑。\n安装\n既然是服务器上运行，那就还是使用Docker来安装比较方便了。Docker中提供了多种镜像，这里选择standalone-chrome就好，开箱即用，更多说明参考docker-selenium。\n详细的Docker安装就不做赘述，这里使用Drone CI来使用Selenium，所以阐述下在Drone CI 2.0中的使用。\n\n\n参考\n\n设置shm大小\n\n\n\n使用\n在Golang中使用github.com/tebeka/selenium这个库操作Selenium，使用Chrome版的Selenium进行如下操作\n\n\n参考\n\nhttps://stackoverflow.com/a/53970825\n\n\n\n注意事项\nSelenium中输出的所谓只有本地链接才能使用WebDriver等报错一样的日志，仅仅是提示作用，在Docker中执行并没任何问题，无需理会。\n","path":null},{"url":"https://yzzfo.github.io/blog/在Unity中使用Golang/","title":"在Unity中使用Golang","description":null,"body":"在Unity中使用Golang\n最近用Golang写了一些工具，于是就想着能不能移植到Unity中使用，众所周知Golang可以很方便的跨平台编译也可以和C交互，而Unity也是可以和C交互的，都可以通过动态链接库的形式进行连接，于是乎开始尝试在Unity中使用Golang的库。\n在Golang中编译链接库是使用CGO进行编译的，这就导致不能像编译普通Golang程序一样轻松跨平台，需要解决如下几点:\n\n安装指定平台的GCC和G++\n启用CGO\n设置目标架构和系统\n设置使用的GCC和G++\n\n安装GCC和G++\n\n对于Win来说有3种途径: Mingw，MSys2，tdm-gcc，前两种由于网络原因并不怎么好安装，即便安装了也还存在一些坑需要配置，个人感觉对于Golang来说tdm-gcc是最好的选择。\nLinux, 我这边使用的Ubuntu系统，其具体安装方式就是直接apt\n\nAndroid虽然也是Linux系统但他不能直接用Linux的库，需要使用NDK进行编译才能使用，在Win下安装NDK，采用NDK中的编译器去编译,安装NDK后设置环境变量NDKROOT和%NDKROOT%\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin\n\n\n设置Golang\n以安卓为例，设置armv7架构的安卓\n\nCompile\n接下来就是编译了\ngo build -buildmode=c-shared -o libv2free.so v2free.go\n编译导出的名字很重要，libxxx.so xxx为库名,如果直接导出xxx.so会报找不到Dll的错误，原因看一篇博文是说Android中查找库是按照这种命名规范来找的。\n接下来就是Unity的调用了\n将so或dll，拖入unity中后设置好他们正确的属性，比如运行的平台，架构等等，这样Unity才可以正确的编译，在Editor中，运行调用的是本地架构的dll，如果只有安卓没有本地架构的dll那就只能安卓测试了。对于安卓来说，设置好项目里的Android API与导出的对应，或者说导出的时候设置的与项目一致，否则可能Crash。\n调用方式如Golang编译一文中所述,接上后就能正常使用了。\n踩到的坑\n感觉像是Unity缓存或者设置的问题，在老项目中编译的安卓会各种闪退，关闭增量GC又好一些，继续关闭多线程渲染，反正各种方法试过还是会出现概率闪退问题，logcat查了调用堆栈指向了GC Crash属实看不懂了，重新开了个Unity导出就好了，感觉以后遇到奇怪问题还是重开个项目试试比较好。\n调试\n安卓ADB调试，在2019中可以下载Logcat插件了，对于安卓ADB调试十分方便，对于ADB的Crash堆栈可以通过IDA和Il2CppDumper两个东西对应着查看，但也可以用更方便的方式，导出在Build时勾选symbols.zip以及各种Debug的东西，这样配合Logcat插件就很舒服了。\n参考资料\n\nCGO交叉编译\nAndroid闪退\n找不到 Runtime CGO\n通过解析libil2cpp.so文件查看Android Crash崩溃原因\n将Go代码编译成动态链接库，android通过JNI调用\nAndroid使用Golang代替C/C++进行Native开发\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Drone/","title":"Drone","description":null,"body":"Drone\ndrone是一个轻量CI/CD工具，主要是基于docker部署和使用，十分方便。\ndrone分为两部分客户端和服务端，服务端用来下发任务，客户端用于执行\n安装\n本文基于Github进行部署\n\n\nGithub相关设置\n创建应用\n\n\n生成RPC用的密钥\nopenssl rand -hex 16\n\n\n服务端Docker-Compose文件\n\n\n\n客户端Docker-Compose配置\n\n\n\n使用\n参考官方案例\n由于官方使用的是Docker-image执行的各种构建工作，所以有上下运行环境的不一致的情况\n比如\n\nyaml 多行代码\n\n关于字符串操作等涉及环境变量的，很容易出现格式问题\n比如\n\n解决方法参考\n\nhttps://discourse.drone.io/t/multiple-substitution/2822\nhttps://docs.drone.io/pipeline/environment/syntax/\nhttp://docs.drone.io/substitution/\nhttps://wiki.bash-hackers.org/syntax/pe#substring_removal\n\n所以还是在仓库中新建一个shell脚本，进行单行调用最为稳定\n编码问题，比如git diff --name-only 正常情况下会输出八进制的非asicii码，这时可以通过git config core.quotepath off关闭这种转换，参考自\nTrigger\ncustom 该trigger添加上后才可以使用网页上的build按钮手动触发\nVolume\n\nWorkSpace\n\nhttps://blog.csdn.net/kikajack/article/details/80503786\nhttps://www.cnblogs.com/xiaoqi/p/drone-pipeline.html\nhttps://0-8-0.docs.drone.io/workspace/\n\n\nVolume\n\n临时空间\n宿主机空间\n\n\n\nPlugin\n\n新增某文件或文件夹变化的条件\n\n参考自这个回答\nDocker-Compose部署代码\n\n\n\nDocker插件\n\n.drone.yaml配置\n\n\n该插件不支持交叉编译，改用自己编译的crinte/docker镜像去编译docker了用法\n\nEmail\n\nGit Push\n在CI中进行Push可以直接采用Uri token形式git remote add origin https://{username}:{password}@github.com/{username}/project.git\npassword需要使用Github中生成的Token才行了\n\n参考\n\nhttps://stackoverflow.com/questions/22147574/fatal-could-not-read-username-for-https-github-com-no-such-file-or-directo\nhttps://stackoverflow.com/questions/2432764/how-to-change-the-uri-url-for-a-remote-git-repository\n\n\n\n换域名后收不到Webhook了\n在更换域名后并将github上相关的域名也同步修改后发现依旧收不到Webhook，解决方法是将drone中的任务禁用在启用一边，这样就可以正常收到webhook了。\n","path":null},{"url":"https://yzzfo.github.io/blog/UnityEditor/","title":"UnityEditor","description":null,"body":"UnityEditor\n大体流程\n指令形\n类似win上的刷新按钮，点击即执行一个固定的功能\n\n\n交互形\n这种一般就是自定窗口的形式\n\n常用的一些API\n\nUI控件\n\n控件基本存放在GUILayout和EditorGUILayout中，后者就是多个自动布局而已，EditorGUILayout中有的控件GUILayout都有，反之却不成立，所以在EditorGUILayout找不到东西是可以去GUILayout看看，比如Button组件\n文件选择框，UnityEditor自带的APIEditorUtility.OpenFilePanel只能选择单个文件，所以可以使用第三方的插件,该插件需要开启.Net4.x\n\n\n状态相关的API UnityEditor.EditorApplication  如是否正在编译\n资源相关的API AssetDatabase  如资源刷新，资源路径\nPlayerSetting相关的API UnityEditor.PlayerSettings 如宏定义\n编译相关 UnityEditor.Compilation.CompilationPipeline 如重新编译脚本\n工具类API EditorUtility PrefabUtility 等一系列Utility结尾的API，具体参考文档\n回调事件 UnityEditor.Callbacks包含事件属性，在函数上加上对应事件属性即可，可以用来build或complile时的IL注入\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Golang编译/","title":"Golang编译","description":null,"body":"Golang编译\n交叉编译\n\n设置导出的平台export GOOS=\"linux\"\n设置导出的架构export GOARCH=\"amd64\"\ngo build -o 导出的名字 要编译的文件go build -o tg_bot.exe ./\nWin下导出程序\n\nDll导出\n\nGCC安装\n\n\n\n在win下有Mingw，MSys2，tdm-gcc这几种方法安装，前两种由于网络以及自带库的一些问题安装起来较为费事，所以推荐采用第三种方式进行安装，安装即可在Golang中使用了\n\n\n\n导出指令\ngo build --buildmode=c-shared -o xxx.dll\n代码事项\n\n\n\nC#中使用Dll\n\n\nBuild的一些参数\n\n-ldflags 'flag list'\n'-s -w': 压缩编译后的体积\n-s: 去掉符号表\n-w: 去掉调试信息，不能gdb调试了\n\n","path":null},{"url":"https://yzzfo.github.io/blog/利用GitHook自动上传文章/","title":"利用GitHook自动上传文章","description":null,"body":"利用GitHook自动上传文章\n涉及的工具\n\n流程\n在markdown工具中写好文章后，保存到git中，触发githook后运行pandoc导出html形式的文章，最后通过golang调用wordpress的api进行文章创建或更新操作\ngit服务器的搭建\n我这边服务器选择用本地的树莓派来搭建，git服务端和客户端的操作流程即便一样，网上大多教程采用git init --bare来初始化服务端的仓库，但这样操作出来的仓库似乎就只有存储的作用，故我这边还是选择git init直接创建一个仓库,至于要不要创建一个专门的git用户用来进行仓库通信就全凭喜好了。\n仓库创建好后自然是客户端链接上去试试，链接过程和链接Github的仓库一样，git remote add 服务名 ssh://username@ip:port，至此仓库是已经通了。\n安装Pandoc\n在树莓派中安装pandoc,pandoc已经在apt中包含了，直接sudo apt-get install pandoc -y，关于pandoc的使用Demo\n文章上传\n接下来考虑如何上传文章,这里调用golang中的一个wordpress库，在网上看到wordpress也有xml-rpc试了一试感觉还是调库来的舒服，主要容易遇到wordpress拒绝访问的问题，解决方法就是用户-&gt;所有用户-&gt;编辑用户-&gt;添加新的应用程序密码，用这个密码代替登陆密码即可访问。关于这个库的使用见restful api\nGitHook\n剩下就是GitHook了,hook事件选择post-receive,该事件的时间点在push结束,可以在该事件中获取到前后的commit的信息，可以用来筛选该操作的文件,具体代码如下。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/MonoCecil/","title":"Mono.Cecil","description":null,"body":"Mono.Cecil的使用\n最近看了下ILRuntime以及基于ILRuntime实现的XIL源码，发现他们核心都在于使用了Mono.Cecil，所以去看了看Mono.Cecil的使用，Mono.Cecil是用于在C#中实现AOP编程的一个库，AOP有两种实现方式，一种是预编译另一种是运行时，Mono.Cecil属于预编译类型，通俗的来说就是直接修改Dll文件达到修改函数行为的效果。\nMono.Cecil中的结构\nAssembly\n\n\nModuls\n\n\nTypes\n\nFields\nMethods\nProperties\n\n\n\n\n\nWiki\nHome · mono/cecil Wiki (github.com)\nDefinition和Reference\nMono.Cecil中的类型不同于C#反射中的Type，Mono.Cecil的操作级别属于metadata，这也就让其类型有了Definition和Reference之分，对于Definition就是定义于该Dll里的类型和方法，Reference就是不属于该Dll中的类型和方法。Definition和Reference区分十分重要，在实际编写代码的过程中，即便区分错误了Mono.Cecil也不会报错的情况，甚至运行结果正确，但第二次以及后续运行时则会发生奇奇怪怪的问题，例如在Unity中，首次通过Mono.Cecil进行IL注入后，代码运行符合预期，但是后续在Unity中修改代码，重新编译并不会生效，只能重启Unity才能恢复正常，再次注入IL后将继续导致编译失效。原因在于自引用问题，自己引用了自己。\nDefinition\nDefinition自然指的是定义，就类似于.cs文件一样，代码的修改就位于Definition中。\nReference\nReference自然指的是引用，若需要调用非该程序集的类型时就需要导入Reference，若时本程序集的则使用Definition类型即可(Definition继承自Reference)\nGeneric\n在Mono.Cecil中泛型属于Reference范畴，一旦Resolve后变成Definition将失去输入的泛型数据，例如:Singlton,\n想要构造一个Singlton,只需要获取到Singlton的Reference构造一个GenericInstanceType然后传入GenericArguments即可\n","path":null},{"url":"https://yzzfo.github.io/blog/Curl/","title":"Curl","description":null,"body":"Curl\n\n上传文件\n\nmultiform-data\n\n一个key对应一个文件curl -F \"image=@file1.gif\" -F \"image2=@file2.gif\"  http://localhost:8888/web/Upload.php\n一个key对应一列表文件curl -F \"image[]=@file1.gif\" -F \"image[]=@file2.gif\"  http://localhost:8888/web/Upload.php\n\n\nwebDav\n\ncurl -T file.txt http://localhost:8888/web/path/to/file.txt\n\n\n\n\n\nupload multiple files to php server using curl command line - Stack Overflow\n","path":null},{"url":"https://yzzfo.github.io/blog/Golang爬虫/","title":"Golang爬虫","description":null,"body":"Golang爬虫\n\n\n教程资料\n\n爬虫从入门到精通系统教程---目录 - 知乎 (zhihu.com) --- 主要的核心计算和理论\nGolang 爬虫快速入门 | 获取 B 站全站的视频数据 | Go 技术论坛 (learnku.com) ---- 用来快速浏览下Go的写法而已\n\n\n\n工具知识\n\n为什么 JSON 需要转义 - LoveIt (yousali.me)\nregex101: build, test, and debug regex 动画版的调试正则表达式，十分有利于理解正则表达式\nScraping Framework for Golang (go-colly.org)\ngoquery的使用_Clown95-CSDN博客_goquery\n使用github的api上传文件到项目 (stong-chen.github.io)\n\n\n\n一些工具\nSelectorGadget Chrome 插件方便测试选择器\nhttps://www.toolnb.com/ 一个工具网站，可以用于测试一下编码解码的事情\n","path":null},{"url":"https://yzzfo.github.io/blog/TelegramBot入门/","title":"TelegramBot入门","description":null,"body":"TelegramBot入门\n\n\nDay 23-Telegram Bot：Inline keyboard&amp;callback_query - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)\n\n\nTg_Bot库\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/游戏中的算法/","title":"游戏中的算法","description":null,"body":"Shader算法\n画函数图像\n\n\n\n\n两种不同方式下的smooth函数区别\n两者都做到了 （-0.01，0.01）区间范围内的显示，但Plot1的中单个Smooth长度为0.02，而Plot2中单个Smooth长度为0.01这是两者的一种差别。即Plot1是基于原本区间进行的变化操作，而Plot2则是通过两个不同区间的smooth合并而成的操作。\nRGB和HSV转换\nFrom RGB to HSV in OpenGL GLSL - Stack Overflow\nBlog: Fast branchless RGB to HSV conversion in GLSL – Lol Engine\n灰度值计算\n\nSobel边缘检测\n\nShader画正多边形\n\n\n\n\n\n\nShader噪声\nIntroduction of Noise – 淺談雜訊 – 阿祥的開發日常 (wordpress.com)\nNoise, a Unity C# Tutorial (catlikecoding.com)\nThe Book of Shaders: Noise\nGLSL Noise Algorithms (github.com)\n噪声的艺术 - xiaOp的博客 (xiaoiver.github.io)\n常规算法\n波函数坍缩\n","path":null},{"url":"https://yzzfo.github.io/blog/Golang-Web笔记/","title":"Golang-Web笔记","description":null,"body":"Golang-Web笔记\n\n\n用到的工具网站\n\nHTTP | MDN (mozilla.org)\n\n\n\n踩到的一些坑\n\ngo - Golang cant get body from request.GetBody() - Stack Overflow\ngolang socket中tcp中的ioutil.ReadAll阻塞的问题 - Go语言中文网 - Golang中文社区 (studygolang.com)\nCDN使用后没有Content-Length\ngo - Unable to set query parameters manually for a rest api (using mux) - Stack Overflow\n\n\n\n参考资料\n\n深入Go UDP编程 | 鸟窝 (colobu.com)\nGo Gin 文档 |《Gin 框架中文文档 2019》| Go 技术论坛 (learnku.com)\nGO语言html模板 - 我是一条最咸的咸鱼 - 博客园 (cnblogs.com)\n\n\n\n数据库的使用\n\nmongo · pkg.go.dev 参考官方例子即可\n\ndocker exec  mongo mongodump -h 127.0.0.1:27017  -u username -p password -o /data/db/backup\n同时使用多个tag\n\n\n\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Golang中的接口/","title":"Golang中的接口","description":null,"body":"Golang中的接口\n在Golang中空接口 interface{}和C#中的object类似都可以作为基类来使用，但不同于C#，Golang中存在指针对象，于是 **interface{}**在实际使用中就需要区分清楚传递的数据类型。\nGolang中赋值本质上都是值类型的的传递，指针也是一种值对象，只不过可以通过它找到一个指定的内存地址而已\n如下例子:\n\n可以看出，往空接口赋值实际上是创造了一个新的值对象 interface{} 但Golang可以解析出这个值内部所存的类型究竟是什么，最后返回出来，这就造成了表面上看起来 x 是一个真正的 A 一样，但实际上他们不是同一种结构对象。\n这种区别的使用疏忽容易导致一些数据转换的错误，如Json转换，go - why unmarshal make the type of object changed in golang - Stack Overflow，该问题就是把 interface{}当成了目标结构体指针导致的，Json转换也是指针单层解析，并不支持嵌套指针，再者如下面关于接口中的值*部分所诉，从接口中也无法直接修改所存结构体的值，必须拷贝一份在重新赋值，无疑是增加了代码实现的成本，且没什么必要。\ngo - \" is pointer to interface, not interface\" confusion - Stack Overflow关于指针接口的一个回答\n关于接口中的值\n如下一段类型转换代码\n\n通过这个例子也可以发现，为何推荐向**interface{}**中保存指针类型而不是值类型了。\nWhen to use a function which receives a pointer to interface - Getting Help - Go Forum (golangbridge.org)\n","path":null},{"url":"https://yzzfo.github.io/blog/傅里叶变换/","title":"傅里叶变换","description":null,"body":"傅里叶变换\n\n\n欧拉公式几何意义(可视化)\n${\\huge \\displaystyle e^{i \\Theta }}$代表在二维平面中绕着单位圆旋转${\\displaystyle \\Theta }$弧度\n​\t\n\n\n傅里叶变换\n${\\huge \\displaystyle f( \\xi ) \\ =\\int _{-\\infty }^{+\\infty } f( t) e^{-2\\pi it\\xi } dt}$\n$\\xi$ 代表频率\nt 代表时间\n固可知 ${\\Large \\displaystyle {t\\xi }}$ 代表总共经过的周期数\n结合欧拉公式的几何意义可知在${\\Large \\displaystyle e^{-2\\pi it\\xi }}$ 中${\\Large \\displaystyle {t\\xi }}$代表绕圆顺时针旋转的圈数\n${\\Large f( t) e^{-2\\pi it\\xi }}$则表示将${\\Large f(t)}$绕着圆随时间缠绕上去\n整体傅里叶变换则表示，在频率 ${\\Large \\displaystyle {\\xi }}$ 固定的情况下将${\\Large f(t)}$持续缠绕上去所形成的一个累积点，当频率 ${\\Large \\displaystyle {\\xi }}$ 等于${\\Large f(t)}$的频率时或者为整数倍时，则会随着一个方向无限增大，当频率${\\Large \\displaystyle {\\xi }}$ 不等于${\\Large f(t)}$的频率时则会随着圈数的增多均匀化，最终处于小范围内的振荡。\n\n\n参考资料\n【官方双语】形象展示傅里叶变换_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili\n傅里叶变换 - 维基百科，自由的百科全书 (wikipedia.org)\n","path":null},{"url":"https://yzzfo.github.io/blog/Caddy2/","title":"Caddy2","description":null,"body":"Caddy2\n\n\n开启http3\n\n\n\n反向代理\n\n使用reverse_proxy 而不是caddy1时的reverse_proxy /* 表示反代proxy_host:port下的所有路径\n\n\n添加网页登陆密码\n\n\nbash下执行caddy hash-password 密码得到对应的hash值JDJhJDE0JENDbEU1ZmhPelR2RmQwNnJ2L0FldmVtODdWNG01SmR5NzExeXNBS05vWkJOdG02YzhOVVZL\n在想要加密的网站中添加如下配置即可:\n\n例如:\n\n\n代理nextcloud示例\n\n\n\n[Caddy文档](Welcome — Caddy Documentation (caddyserver.com))\n\n","path":null},{"url":"https://yzzfo.github.io/blog/变换矩阵/","title":"变换矩阵","description":null,"body":"\n\n矩阵变换的基本层次结构\n\n透视变换射影变换\n\n仿射变换\n线性变换\n\n旋转\n缩放\n\n\n\n\n\n\n\n矩阵各项的含义(可视化模型)\n$\n\\begin{bmatrix}\na &amp; b &amp; o_{x}\\\nc &amp; d &amp; o_{y}\\\np_{x} &amp; p_{y} &amp; 1\n\\end{bmatrix} \\\n$\n\n该三维矩阵作用于二维平面时其各部分含义分别为:\n\n线性变换\n$\n\\begin{bmatrix}\na &amp; b\\\nc &amp; d\n\\end{bmatrix} \\\n$\n平移变换\n$\n\\begin{bmatrix}\no_{x}\\\no_{y}\n\\end{bmatrix} \\\n$\n透视变换\n$\n\\begin{bmatrix}\np_{x} &amp; p_{y}\n\\end{bmatrix} \\\n$\n\n\n\n\n\n三维空间中的变换矩阵\n$\n\\begin{bmatrix}\na &amp; b &amp; c &amp; o_{x}\\\nd &amp; e &amp; f &amp; o_{y}\\\ng &amp; h &amp; i &amp; o_{z}\\\np_{x} &amp; p_{y} &amp; p_{z} &amp; 1\n\\end{bmatrix} \\\n$\n\n性质同作用域二维平面的三维矩阵一样\n\n\n\n函数组合\nRsl - Using Smoothstep (fundza.com)\nEasing Functions Cheat Sheet (easings.net)\n工具\n\nMathcha\nGeogebra\n\n","path":null},{"url":"https://yzzfo.github.io/blog/C# Expression Tree/","title":"C# Expression Tree","description":null,"body":"在C#中Linq语句可以使得许多数据处理逻辑写起来十分方便，在Linq存在一种Expression的概念，用它可以动态构建许多方法用来增强逻辑处理能力。\n利用表达式树映射对象属性\n有时候会存在两个很相似的类，但他们却不隶属同一个父类或接口，这时候想进行相互赋值就可以使用表达式树来构建这种映射关系。\n\n数据绑定\n有时候知道两个数据应该是相互关联的，调整一个的时候另一个也要同时变化，这时候可以通过Lambda传递数据路径来构造表达式，进行数据关联。\n\n","path":null},{"url":"https://yzzfo.github.io/blog/C# Attribute的使用/","title":"C# Attribute的使用","description":null,"body":"实现一个Attribute用于标记要运行加载的单例\n\n在Main中调用InitOnLoad.Initialise()便会自动加载所有标记过该Attribute的对象\n","path":null},{"url":"https://yzzfo.github.io/blog/Shader 笔记/","title":"Shader 笔记","description":null,"body":"为什么有时候能看到类似float3*float2\n\n这里的乘法是逐分量的乘法，也就是说，每个分量都分别乘以对应的值。例如，float3(a,b,c) * float2(x,y) 等价于 float3(a_x,b_y,c)。\n\n如何把NDC空间下的坐标转换成屏幕空间下的UV坐标呢？\n\n要把NDC空间下的坐标转换成屏幕空间下的UV坐标，可以用以下公式：\nxuv = (xndc + 1) / 2\nyuv = (yndc + 1) / 2\n其中，xndc和yndc是NDC空间下的坐标，xuv和yuv是屏幕空间下的UV坐标。这个公式是把[-1, 1]范围内的NDC坐标映射到[0, 1]范围内的UV坐标。\n\nComputeScreenPos和NDC下UV的区别\nUnity Shader中的ComputeScreenPos函数 - 知乎 (zhihu.com)\nComputeScreenPos是Unity shader提供的一个内置函数，它可以根据顶点位置计算出屏幕坐标。它返回一个float4，其中xy分量是屏幕坐标，w分量是齐次坐标。要得到UV坐标，可以用xy除以w\n通过ComputeScreenPos计算而来的屏幕坐标用其算出的UV和NDC空间下转换的UV有一些区别。主要是因为ComputeScreenPos考虑了不同平台上的投影参数，而NDC空间下转换的UV没有考虑这些因素\n\n通过SV_POSITION计算UV\n\nComputeScreenPos 应该在Vertex中计算\n在Frag中计算时发现通过用其计算的结果来算uv并不正确，但在Vertex阶段计算，然后在Frag阶段去算uv是正确的，原因在此。\n计算Screen UV的例子\n\n通过Screen Positon计算世界坐标\n\nGL.GetGPUProjectionMatrix的含义\nOpenGL-like（OpenGL and OpenGL ES）和Direct3D-like（Direct3D, Metal and consoles）对Clip space的表达是不一样的，这会导致projectionMatrix会不一样，这也就是Unity提供GL.GetGPUProjectionMatrix的原因，GL.GetGPUProjectionMatrix会将Camera.projectionMatrix转换为当前GPU平台对应的表达\n\n\nUnity Shaderlab- transform from screen space to world space\n从NDC（归一化的设备坐标）坐标转换到世界坐标要点\n\n内置着色器变量\n一些常用变量\nSV_POSITION\n\nxy 屏幕坐标\nz 深度值，同ZBuffer中存储的格式一样\nw clip space下的w，在Unity中同View Space下的z\n\n_ProjectionParams\n\nx 用于判断y是否需要翻转\n\n_ScreenParams\n\nxy 屏幕大小\n\nShader指令\nAlphaTest\n\nAlphaTest选项\n\nGEqual\nEqual\nNotEqual\nLess\nLequal\nAlways\nNever\n\n\n\n\nStencil\n\nBlend混合\n\nBlend选项\n\nSrc\n\nSrcColor\nSrcAlpha\nOne MinusSrcColor\nOneMinusSrcAlpha\n\n\nDst\n\nDstColor\nDstAlpha\nOneMinusDstColor\nOneMinusDstAlpha\n\n\nOne\nZero\n\n\nBlendOp选项\n\nAdd\nSub\nRevSub\nMin\nMax\n\n\nBlend的等式(SourceRGBA*Something) + (DestRGBA*Something)``BlendOp即用于替换等式之间的+如Min((SourceRGBA*Something),(DestRGBA*Something))\n\nColorMask\n\nGrabPass\nGrabPass{ _CustomTex }抓取屏幕内容并命名为_CustomTex的贴图 若未设置 _CustomTex 则默认名字为 _GrabTexture\nShader固定管线\n对于固定渲染管线Combine中也可以在其Pass中定义诸如AlphaTest，Stencil，Blend这样的指令并生效，使用方法同其他方式一致。\nUnityShader之固定管线命令Combine纹理混合【Shader资料4】 - 威少小二orz - 博客园 (cnblogs.com)\n额外资料\nUnity rendering order 整理筆記 (twsiyuan.com)\n源码探析Mask、Rect Mask2D与Sprite Mask的异同 (renkaikai.com)\n","path":null},{"url":"https://yzzfo.github.io/blog/Docker-Compose笔记/","title":"Docker-Compose笔记","description":null,"body":"\nDocker-Compose安装\npip install docker-compose 或者 apt-get install docker-compose\nDocker-Compose使用\n\ndocker-compose.yaml的选项\n可以通过inspect查看container的json文件用以yaml的选项结构参考\n\ncompose中不常用选项的示例\n参考资料\n\ncompose-file-v3\n\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Raspberry/","title":"Raspberry","description":null,"body":"Raspberry\n\n\n安装部分\n\nboot下新建ssh文件开启ssh连接\n设置root密码 sudo passwd\n设置apt源\n\n源在线配置\n清华源\n\nUbuntu\n\nx86\n其他架构\n\n\nRasp os\n\n\n\n\n设置静态IP nano /etc/dhcpcd.conf\n\n\n\nDocker安装\n\nDocker安装\nDocker源配置\n\n重启Docker systemctl restart docker\n查看是否配置成功 docker info\n安装docker-compose\n\n安装pip sudo apt install python3-pip\n更换pip源\n安装docker-compose pip install docker-compose\n\n\n\n\n\n配置全局变量\n\n/etc/profile 全局变量\n~/.bashrc 用户全局变量\n\n\n\nOpenwrt安装\n\ndocker版openwrt安装教程\n\n对于Raspberry来说，lan口物理设置中的桥接需要关闭,否则将导致外部设备将其设为网关时无法访问网络\n\n\n\n\n\n采用docker-compose安装大部分应用\n\ndocker-compose配置\ndocker-compose up -d\n\n\n\n挂载smaba\n\nuid和gid的数字可以改为直接输入用户名和组名\nx-systemd.automount,x-systemd.idle-timeout=30用于自动挂载，例如访问**/mnt/nas**时将自动挂载\nfmask和file_mode之间的关系，fmask就是过滤的权限，file_mode就是本身的权限 file_mode&amp;(!fmask)就是文件生成时所设置的权限如 0777-0222 = 0555\nfstab Wiki\n\n\n常用包\n\nscreen\n\n-S\nscreen -S screenName 创建一个名为screenName的窗口\n-r\nscreen -r screenName 重新进入screenName这个窗口\ncrtl+A+D detach窗口\n-D\nscreen -D screenName detach窗口\n\n\ncpulimit\ncpulimit -p pid -l 0.5 限制pid进程cpu占用率不超过50%\n\nLinux工具类网站\n\nBash Hackers Wiki\n\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Golang笔记/","title":"Golang笔记","description":null,"body":"Golang笔记\nGolang库管理\n\nGolang mod导入本地库\n\n\n同一项目下：\n\nmoduledemo/go.mod中如下定义:\n\n在main.go中 import \"modulename/packdir\"\t即model/目录\n\n\n不同项目下\n\nmodulea导入moduleb设置go.mod\n\n\n\n\n\nGolang库\nexec\n运行并获得输出，阻塞式 exec.Command(\"ping\", \"www.baidu.com\").Output()\n非阻塞式使用Pipe\nrsrc\n给win下程序添加图标，管理员权限之类的工具\n在main程序目录下新建一个xxx.manifest文件，要Build时先运行rsrc -arch amd64 -manifest xxx.manifest -o xxx.syso arch默认为amd64，运行后直接build -o xxx即可，默认build状态下会引用当前目录下的所有东西，以此来达到引用xxx.syso的目的，若要编译linux下的程序，删除xxx.syso即可\nandroiddnsfix\n用于修复golang编译的程序无法在安卓中正常使用dns的问题\nGolang资源\n\n电子书\nGoWeb编程\nGo语言高级编程\nGo 7 Days\n在线工具:\nJson&gt;&gt;&gt;Go\n\n","path":null},{"url":"https://yzzfo.github.io/blog/Docker笔记/","title":"Docker笔记","description":null,"body":"Docker笔记\nDocker安装\n\nDockerfile\n\n\nFROM\nFROM 以某个Image为基础\nFROM ubuntu[:版本号|@hash]\n\n\nLABEL\nLABEL 说明信息\nLABEL version=\"1.0\"\n\n\nRUN\nRUN build时执行的命令，每执行一条就多一层构建纪录，Docker的构建类似一个命令队列，一条一条的命令构建出一个Image，FROM image就是调用别人写好的命令，再此基础上继续添加自己的命令\nRUN apt-get update&amp;&amp;apt-get install xxx\n\n\nWORKDIR\nWORKDIR 指定工作目录，就是进入docker后所在的目录，若不存在则创建目录\nWORKDIR /root 进入root目录\n\n\nADD and COPY\nADD and COPY 将本地文件添加到镜像里 创建文件夹的话先用WORKDIR\nADD 可以解压文件\nADD hello.tar.gz / 添加并解压hello到根目录\nCOPY hello.tar.gz / 添加hello.tar.gz到根目录\n\nCOPY的另一个用处\n\n\n\n\nENV\nENV 环境变量\n\n\n\nCMD and ENTRYPOINT\n不同于Run是build时运行的，CMD和ENTRYPOINT是Image&gt;&gt;&gt;Container时执行的\n\n\n命令的两种写法\n\n\nshell格式\n\n\n\nexec格式\n\n\n\n\n\nshell和exec的区别\nexec格式不支持 $xxx 常量替换 因为 $xxx 是shell才有的功能，可改用 sh -c \"指令\"用shell解析\nCMD [\"sh\",\"-c\",\"apt-get install $xxx\"]\nCMD和ENTRYPOINT区别\n若docker指定了其他的指令，CMD可能被忽略\nCMD作为命令情况\n比如CMD前面有多个CMD，只执行最后一个CMD\n存在ENTERPOINT则CMD不执行\nCMD作为参数情况\n\n执行docker run xxximage会出现have not input param\n执行docker run xxximage input param会出现input param\n即可发现 CMD 在该例子中作为了未输入参数时所填入的 默认参数\n具体可看CMD和ENTRYPOINT区别\n\n\n\n\nVolume\n\n\n设置挂载点 Volume [\"/cfg\"] 会在容器内创建文件夹/cfg,容器运行时，若未 -v 明确指出挂载位置，则会采用匿名挂载的形式在 /var/lib/docker/volumes/ 文件夹下面创建对应的文件\n\n\nDockerfile的命令都是有顺序的，Volume指定时便会在容器内创建指定的文件,Volume不能覆盖已存在的文件，若文件已存在则报错\n\n\n\n\n\nDock Image生成方式\n\n\nDockerfile方式\n\n\n\n将现在的容器变为镜像\n\n\n\n导出Image\n上述两种方式并没有直接生成一个Image文件供用户进行分享，此时可以导出Image文件供用户分享\n\n\n\n导入本地Image文件\n\n\n\nDocker-Image交叉编译\n\n采用Docker虚拟机\n\ndocker run --rm --privileged multiarch/qemu-user-static:register --reset 注册 qemu-user-static 虚拟机\n虚拟机镜像\nDockerfile的FROM换成对应架构的虚拟机镜像，其他步骤不变\n\n\nGit Action编译案例\n参考的博客\nx86 下制作 ARM Docker 镜像\n\n\n采用buildx构建\n\n如果是在drone-ci中通过docker来交叉编译则可以先编译一个支持buildx的docker容器\n\n如果是采用docker容器进行buildx则需要将宿主机的/var/run/docker.sock绑定到容器中的/var/run/docker.sock\ndocker程序的通用步骤\n\n登陆docker docker login -u username\n挂载编译工具 docker run --privileged --rm tonistiigi/binfmt --install all，重启后需要重新挂\n创建一个builder docker buildx create --name builder\n使用builder docker buildx use builder\n编译并上传docker buildx build --platform=linux/amd64,linux/386,linux/arm64,linux/arm/v7 -t crinte/pango --push . 如果不想上传可以把push改load即载入本地\n\n\n参考资料\n\nhttps://docs.docker.com/buildx/working-with-buildx/\nhttps://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/\nhttps://www.docker.com/blog/multi-arch-images/\nhttps://www.cnblogs.com/nihaorz/p/12021700.html\nhttps://zhuanlan.zhihu.com/p/299116754\n\n\n\n\n\n\n\nDocker常用的一些指令\n\ndocker pull\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]\ndocker run\n\n\n-v/--volumes\n\n\n\n--link Link机制的实现原理\n\n\n\n-p\n\n\n\n-e\n\n\n\n-u\n设置PUID和PGID\n-u 0:0\n\n\n--privileged\n以特权模式进行\n通常情况下container的root在宿主机角度来看就是个普通用户\nprivileged下container的root有了宿主机root的权限\n\n\n性能设置相关的参数\n\n-cpus\n分配给docker的cpu数目\n如果主机有4个cpu逻辑cpu则-cpus 2为占用总cpu的50%性能\n\n--cpu-period和--cpu-quota\n分别为cpu一个周期的时间和docker一个周期可以占用cpu的时间\n\n\n--cpuset-cpus\n--cpuset-cpus=\"0,1,2\"或者--cpuset-cpus=\"0-2\"使用0-2号处理器\n--cpu-shares\n多容器竞争同一处理器时且时间不足时的分配权重\n\n\n\n\n\nUID和GID在Docker中的几种写法\n\n-u $UID:$GID \n-u $(id -u):$(id -g)\n\nDocker Network\n\n\nbride\n\n\nhost\n类似于将container直接变本地应用，端口直接就是宿主机的端口\n\n\nmacvlan\n\n使用macvlan时，容器无法与宿主机通信，即便在同一个网段也不能通信，解决方法\n\n\nnone\n\n\nContainer连接宿主机\n\n\nDocker Dead\nContainer处于Dead状态时无法rm掉，此时可以用下面代码进行移除\n\nDocker-UI管理界面\n\n\nPortainer\n​    By default, Portainer will expose the UI over the port 9000 and expose a TCP tunnel server over the port 8000\n\n\n\ndocker容器中查看容器linux版本\n有时候需要登陆容器搞点事情，这时候需要看容器系统的版本，那么一条命令就能完成。\n正确的姿势：\ncat /etc/issue\n错误的姿势:\ncat /proc/version 或 uname -a ，这样查到的是宿主机的系统。\ndocker中使用ipv6\nDocker对ipv6的支持并不是很好，配置起来也有一些坑，这里记录一下简单的方法。\n\n编辑/etc/docker/daemon.json\n\nsystemctl restart docker\n安装docker-ipv6nat\n创建容器时使用bridge网络或者创建一个docker network create --ipv6 --subnet fd00:dead:beee::/48 mainv6\n在docker-compose中进行相关配置\n\n\nDocker相关的资源\n1.Doker-Labs在线实验Docker的平台\n&nbsp;&nbsp;&nbsp;ssh连接Docker-Labs需要本地生成密钥\n&nbsp;&nbsp;&nbsp;在win10环境下安装Git-Bash后执行ssh-keygen -t rsa -P \"\" -f ~/.ssh/id_rsa  生成密钥\n2.Docker Volume详解\n3.Docker入门到实践\n","path":null},{"url":"https://yzzfo.github.io/","title":"yzzfo's Blog","description":null,"body":"Hello World.\n","path":null},{"url":"https://yzzfo.github.io/bookmarks/","title":"List of bookmarks","description":null,"body":"","path":null},{"url":"https://yzzfo.github.io/bookmarks/关于 Safari 100vh 的问题与解决方案/","title":"关于 Safari 100vh 的问题与解决方案","description":null,"body":"","path":null},{"url":"https://yzzfo.github.io/bookmarks/Alpha is Transparency的实现方式/","title":"The Texture2D equivalent of Alpha is Transparency for LoadImage png","description":null,"body":"\n","path":null},{"url":"https://yzzfo.github.io/bookmarks/揭开 baseline & line-height & vertical-align 的面纱/","title":"揭开 baseline & line-height & vertical-align 的面纱","description":null,"body":"","path":null}]